[{"title":"📖 Getting started","type":0,"sectionRef":"#","url":"/v1.x/","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#installation","content":"First of all, download and install Go. 1.11 or higher is required. Installation is done using the go get command: go get -u github.com/gofiber/fiber  "},{"title":"Zero Allocation​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#zero-allocation","content":"caution Some values returned from fiber.Ctx are not immutable by default Because fiber is optimized for high-performance, values returned from fiber.Ctx are not immutable by default and will be re-used across requests. As a rule of thumb, you must only use context values within the handler, and you must not keep any references. As soon as you return from the handler, any values you have obtained from the context will be re-used in future requests and will change below your feet. Here is an example: func handler(c *fiber.Ctx) { result := c.Param(&quot;foo&quot;) // result is only valid within this method }  If you need to persist such values outside the handler, make copies of their underlying buffer using the copy builtin. Here is an example for persisting a string: func handler(c *fiber.Ctx) { result := c.Param(&quot;foo&quot;) // result is only valid within this method newBuffer := make([]byte, len(result)) copy(newBuffer, result) newResult := string(newBuffer) // newResult is immutable and valid forever }  We created a custom ImmutableString function that does the above and is available in the gofiber/utils package. app.Get(&quot;/:foo&quot;, func(c *fiber.Ctx) { result := utils.ImmutableString(c.Param(&quot;foo&quot;)) // result is now immutable })  Alternatively, you can also use the Immutable setting. It will make all values returned from the context immutable, allowing you to persist them anywhere. Of course, this comes at the cost of performance. For more information, please check #426 and #185. "},{"title":"Hello, World!​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#hello-world","content":"Embedded below is essentially the most straightforward Fiber app, which you can create. package main import &quot;github.com/gofiber/fiber&quot; func main() { app := fiber.New() app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Send(&quot;Hello, World!&quot;) }) app.Listen(3000) }  go run server.go  Browse to http://localhost:3000, and you should see Hello, World! on the page. "},{"title":"Basic routing​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#basic-routing","content":"Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, PUT, POST and so on). info Each route can have multiple handler functions, that is executed when the route is matched. Route definition takes the following structures: // Function signature app.Method(path string, ...func(*fiber.Ctx))  app is an instance of Fiber.Method is an HTTP request method, in capitalization: Get, Put, Post, etc.path is a virtual path on the server.func(*fiber.Ctx) is a callback function containing the Context executed when the route is matched. Simple route // Respond with &quot;Hello, World!&quot; on root path, &quot;/&quot; app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Send(&quot;Hello, World!&quot;) })  Parameters // GET http://localhost:8080/hello%20world app.Get(&quot;/:value&quot;, func(c *fiber.Ctx) { c.Send(&quot;Get request with value: &quot; + c.Params(&quot;value&quot;)) // =&gt; Get request with value: hello world })  Optional parameter // GET http://localhost:3000/john app.Get(&quot;/:name?&quot;, func(c *fiber.Ctx) { if c.Params(&quot;name&quot;) != &quot;&quot; { c.Send(&quot;Hello &quot; + c.Params(&quot;name&quot;)) // =&gt; Hello john } else { c.Send(&quot;Where is john?&quot;) } })  Wildcards // GET http://localhost:3000/api/user/john app.Get(&quot;/api/*&quot;, func(c *fiber.Ctx) { c.Send(&quot;API path: &quot; + c.Params(&quot;*&quot;)) // =&gt; API path: user/john })  "},{"title":"Static files​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#static-files","content":"To serve static files such as images, CSS, and JavaScript files, replace your function handler with a file or directory string. Function signature: app.Static(prefix, root string)  Use the following code to serve files in a directory named ./public: app := fiber.New() app.Static(&quot;/&quot;, &quot;./public&quot;) app.Listen(8080)  Now, you can load the files that are in the ./public directory: http://localhost:8080/hello.html http://localhost:8080/js/jquery.js http://localhost:8080/css/style.css  "},{"title":"Note​","type":1,"pageTitle":"📖 Getting started","url":"/v1.x/#note","content":"For more information on how to build APIs in Go with Fiber, please check out this excellent article on building an express-style API in Go with Fiber "},{"title":"🚀 App","type":0,"sectionRef":"#","url":"/v1.x/api/app","content":"","keywords":""},{"title":"New​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#new","content":"This method creates a new App named instance. You can pass optional settings when creating a new instance Signature fiber.New(settings ...*Settings) *App  Example package main import &quot;github.com/gofiber/fiber&quot; func main() { app := fiber.New() // ... app.Listen(3000) }  "},{"title":"Settings​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#settings","content":"You can pass application settings when calling New. Example func main() { // Pass Settings creating a new instance app := fiber.New(&amp;fiber.Settings{ Prefork: true, CaseSensitive: true, StrictRouting: true, ServerHeader: &quot;Fiber&quot;, }) // ... app.Listen(3000) }  Or change the settings after initializing an app. Example func main() { app := fiber.New() // Or change Settings after creating an instance app.Settings.Prefork = true app.Settings.CaseSensitive = true app.Settings.StrictRouting = true app.Settings.ServerHeader = &quot;Fiber&quot; // ... app.Listen(3000) }  Settings fields Property\tType\tDescription\tDefaultPrefork\tbool\tEnables use of theSO_REUSEPORTsocket option. This will spawn multiple Go processes listening on the same port. learn more about socket sharding.\tfalse ServerHeader\tstring\tEnables the Server HTTP header with the given value.\t&quot;&quot; StrictRouting\tbool\tWhen enabled, the router treats /foo and /foo/ as different. Otherwise, the router treats /foo and /foo/ as the same.\tfalse CaseSensitive\tbool\tWhen enabled, /Foo and /foo are different routes. When disabled, /Fooand /foo are treated the same.\tfalse Immutable\tbool\tWhen enabled, all values returned by context methods are immutable. By default, they are valid until you return from the handler; see the issue #185.\tfalse UnescapePath\tbool\tConverts all encoded characters in the route back before setting the path for the context, so that the routing can also work with urlencoded special characters\tfalse BodyLimit\tint\tSets the maximum allowed size for a request body, if the size exceeds the configured limit, it sends 413 - Request Entity Too Large response.\t4 * 1024 * 1024 CompressedFileSuffix\tstring\tAdds suffix to the original file name and tries saving the resulting compressed file under the new file name.\t&quot;.fiber.gz&quot; Concurrency\tint\tMaximum number of concurrent connections.\t256 * 1024 DisableKeepalive\tbool\tDisable keep-alive connections, the server will close incoming connections after sending the first response to client\tfalse DisableDefaultDate\tbool\tWhen set to true causes the default date header to be excluded from the response.\tfalse DisableDefaultContentType\tbool\tWhen set to true, causes the default Content-Type header to be excluded from the Response.\tfalse DisableStartupMessage\tbool\tWhen set to true, it will not print out the fiber ASCII and &quot;listening&quot; on message\tfalse DisableHeaderNormalizing\tbool\tBy default all header names are normalized: conteNT-tYPE -&gt; Content-Type\tfalse ETag\tbool\tEnable or disable ETag header generation, since both weak and strong etags are generated using the same hashing method (CRC-32). Weak ETags are the default when enabled.\tfalse Views\tViews\tViews is the interface that wraps the Render function. See our Template Middleware for supported engines.\tnil ReadTimeout\ttime.Duration\tThe amount of time allowed to read the full request, including body. The default timeout is unlimited.\tnil WriteTimeout\ttime.Duration\tThe maximum duration before timing out writes of the response. The default timeout is unlimited.\tnil IdleTimeout\ttime.Duration\tThe maximum amount of time to wait for the next request when keep-alive is enabled. If IdleTimeout is zero, the value of ReadTimeout is used.\tnil ReadBufferSize\tint\tper-connection buffer size for requests' reading. This also limits the maximum header size. Increase this buffer if your clients send multi-KB RequestURIs and/or multi-KB headers (for example, BIG cookies).\t4096 WriteBufferSize\tint\tPer-connection buffer size for responses' writing.\t4096 "},{"title":"Static​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#static","content":"Use the Static method to serve static files such as images, CSS and JavaScript. info By default, Static will serve index.html files in response to a request on a directory. Signature app.Static(prefix, root string, config ...Static) // =&gt; with prefix  Use the following code to serve files in a directory named ./public Example app.Static(&quot;/&quot;, &quot;./public&quot;) // =&gt; http://localhost:3000/hello.html // =&gt; http://localhost:3000/js/jquery.js // =&gt; http://localhost:3000/css/style.css  To serve from multiple directories, you can use Static numerous times. Example // Serve files from &quot;./public&quot; directory: app.Static(&quot;/&quot;, &quot;./public&quot;) // Serve files from &quot;./files&quot; directory: app.Static(&quot;/&quot;, &quot;./files&quot;)  info Use a reverse proxy cache like NGINX to improve performance of serving static assets. You can use any virtual path prefix (where the path does not actually exist in the file system) for files that are served by the Static method, specify a prefix path for the static directory, as shown below: Example app.Static(&quot;/static&quot;, &quot;./public&quot;) // =&gt; http://localhost:3000/static/hello.html // =&gt; http://localhost:3000/static/js/jquery.js // =&gt; http://localhost:3000/static/css/style.css  If you want to have a little bit more control regarding the settings for serving static files. You could use the fiber.Static struct to enable specific settings. fiber.Static{} // Static represents settings for serving static files type Static struct { // Transparently compresses responses if set to true // This works differently than the github.com/gofiber/compression middleware // The server tries minimizing CPU usage by caching compressed files. // It adds &quot;.fiber.gz&quot; suffix to the original file name. // Optional. Default value false Compress bool // Enables byte-range requests if set to true. // Optional. Default value false ByteRange bool // Enable directory browsing. // Optional. Default value false. Browse bool // File to serve when requesting a directory path. // Optional. Default value &quot;index.html&quot;. Index string }  Example app.Static(&quot;/&quot;, &quot;./public&quot;, fiber.Static{ Compress: true, ByteRange: true, Browse: true, Index: &quot;john.html&quot; })  "},{"title":"HTTP Methods​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#http-methods","content":"Routes an HTTP request, where METHOD is the HTTP method of the request. Signatures // Add allows you to specifiy a method as value app.Add(method, path string, handlers ...func(*Ctx)) Router // All will register the route on all methods app.All(path string, handlers ...func(*Ctx)) Router // HTTP methods app.Get(path string, handlers ...func(*Ctx)) Router app.Put(path string, handlers ...func(*Ctx)) Router app.Post(path string, handlers ...func(*Ctx)) Router app.Head(path string, handlers ...func(*Ctx)) Router app.Patch(path string, handlers ...func(*Ctx)) Router app.Trace(path string, handlers ...func(*Ctx)) Router app.Delete(path string, handlers ...func(*Ctx)) Router app.Connect(path string, handlers ...func(*Ctx)) Router app.Options(path string, handlers ...func(*Ctx)) Router // Use is mostly used for middleware modules // These routes will only match the beggining of each path // i.e. &quot;/john&quot; will match &quot;/john/doe&quot;, &quot;/johnnnn&quot; app.Use(handlers ...func(*Ctx)) Router app.Use(prefix string, handlers ...func(*Ctx)) Router  Example app.Use(&quot;/api&quot;, func(c *fiber.Ctx) { c.Set(&quot;X-Custom-Header&quot;, random.String(32)) c.Next() }) app.Get(&quot;/api/list&quot;, func(c *fiber.Ctx) { c.Send(&quot;I'm a GET request!&quot;) }) app.Post(&quot;/api/register&quot;, func(c *fiber.Ctx) { c.Send(&quot;I'm a POST request!&quot;) })  "},{"title":"Group​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#group","content":"You can group routes by creating a *Group struct. Signature app.Group(prefix string, handlers ...func(*Ctx)) Router  Example func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, handler) // /api v1 := api.Group(&quot;/v1&quot;, handler) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, handler) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user app.Listen(3000) }  "},{"title":"Stack​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#stack","content":"This method returns the original router stack Signature app.Stack() [][]*Route  Example app := fiber.New() app.Use(handler) app.Get(&quot;/john&quot;, handler) app.Post(&quot;/register&quot;, handler) app.Get(&quot;/v1/users&quot;, handler) app.Put(&quot;/user/:id&quot;, handler) app.Head(&quot;/xhr&quot;, handler) data, _ := json.MarshalIndent(app.Stack(), &quot;&quot;, &quot; &quot;) fmt.Println(string(data))  "},{"title":"Listen​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#listen","content":"Binds and listens for connections on the specified address. This can be an int for port or string for address. This will listen either on tcp4 or tcp6 depending on the address input (i.e. :3000 / [::1]:3000 ). Signature app.Listen(address interface{}, tls ...*tls.Config) error  Examples app.Listen(8080) app.Listen(&quot;8080&quot;) app.Listen(&quot;:8080&quot;) app.Listen(&quot;127.0.0.1:8080&quot;) app.Listen(&quot;[::1]:8080&quot;)  To enable TLS/HTTPS you can append a TLS config. Example cer, err := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;) if err != nil { log.Fatal(err) } config := &amp;tls.Config{Certificates: []tls.Certificate{cer}} app.Listen(443, config)  "},{"title":"Listener​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#listener","content":"You can pass your own net.Listener using the Listener method. Signature app.Listener(ln net.Listener, tls ...*tls.Config) error  caution Listener does not support the Prefork feature. Example if ln, err = net.Listen(&quot;tcp&quot;, &quot;:8080&quot;); err != nil { log.Fatal(err) } app.Listener(ln)  "},{"title":"Test​","type":1,"pageTitle":"🚀 App","url":"/v1.x/api/app#test","content":"Testing your application is done with the Test method. Use this method for creating _test.go files or when you need to debug your routing logic. The default timeout is 200ms if you want to disable a timeout altogether, pass -1 as a second argument. Signature app.Test(req *http.Request, msTimeout ...int) (*http.Response, error)  Example // Create route with GET method for test: app.Get(&quot;/&quot;, func(c *Ctx) { fmt.Println(c.BaseURL()) // =&gt; http://google.com fmt.Println(c.Get(&quot;X-Custom-Header&quot;)) // =&gt; hi c.Send(&quot;hello, World!&quot;) }) // http.Request req := httptest.NewRequest(&quot;GET&quot;, &quot;http://google.com&quot;, nil) req.Header.Set(&quot;X-Custom-Header&quot;, &quot;hi&quot;) // http.Response resp, _ := app.Test(req) // Do something with results: if resp.StatusCode == 200 { body, _ := ioutil.ReadAll(resp.Body) fmt.Println(string(body)) // =&gt; Hello, World! }  "},{"title":"🧬 Middleware","type":0,"sectionRef":"#","url":"/v1.x/api/middleware","content":"","keywords":""},{"title":"Compress​","type":1,"pageTitle":"🧬 Middleware","url":"/v1.x/api/middleware#compress","content":"Compress middleware for with support for deflate, gzip and brotlicompression. It will use the fastest compression method depending on the request header Accept-Encodingvalue. Signature func Compress(options ...interface{}) fiber.Handler {}  Config type CompressConfig struct { // Next defines a function to skip this middleware. // Default: nil Next func(*fiber.Ctx) bool // Compression level for brotli, gzip and deflate // CompressLevelDisabled = -1 // CompressLevelDefault = 0 // CompressLevelBestSpeed = 1 // CompressLevelBestCompression = 2 // Default: CompressLevelDefault Level int }  Example // Compression handler with default settings app.Use(middleware.Compress()) // Provide a custom compression level app.Use(middleware.Compress(2)) // Pass a next function to skip specific requests app.Use(middleware.Compress(func(c *fiber.Ctx) bool { return c.Path() == &quot;/dontcompress&quot; })) // Provide a full Config app.Use(middleware.Compress(middleware.CompressConfig{ Next: func(c *fiber.Ctx) bool { return c.Path() == &quot;/dontcompress&quot; }, Level: CompressLevelDefault, })  "},{"title":"Skipping middleware execution​","type":1,"pageTitle":"🧬 Middleware","url":"/v1.x/api/middleware#skipping-middleware-execution","content":"When adding middleware to your application, you can also specify when the middleware should be activated and when it should not through a function passed when initialising the middleware using a function passed in the configuration for the middleware. Signature func (*fiber.Ctx) bool  This function should return true if the middleware should be deactivated. For example, if you would like admin users to be exempt from rate-limiting, you could do something like this: Example app.Use(limiter.New(limiter.Config{ Timeout: 10, Max: 3, Filter: func (c *fiber.Ctx) bool { var isUserAdmin bool // Your logic here return isUserAdmin } }))  caution If you are using middleware that is included with Fiber by default (for example Compress or Logger), you should use the Next field instead of the Filter field. For example: Example app.Use(middleware.Logger(middleware.LoggerConfig{ Format: &quot;${time} ${method} ${path}&quot;, TimeFormat: &quot;15:04:05&quot;, TimeZone: &quot;Asia/Chongqing&quot;, Next: func (c *fiber.Ctx) bool { var isUserAdmin bool // Your logic here return isUserAdmin } }))  "},{"title":"FileSystem​","type":1,"pageTitle":"🧬 Middleware","url":"/v1.x/api/middleware#filesystem","content":""},{"title":"Favicon​","type":1,"pageTitle":"🧬 Middleware","url":"/v1.x/api/middleware#favicon","content":""},{"title":"🐛 Error Handling","type":0,"sectionRef":"#","url":"/v1.x/guide/error-handling","content":"","keywords":""},{"title":"Catching Errors​","type":1,"pageTitle":"🐛 Error Handling","url":"/v1.x/guide/error-handling#catching-errors","content":"It’s essential to ensure that Fiber catches all errors that occur while running route handlers and middleware. You must return them to the handler function, where Fiber will catch and process them. Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { err := c.SendFile(&quot;file-does-not-exist&quot;) if err != nil { c.Next(err) // Pass error to Fiber } })  Fiber does not handle panics by default. To recover from a panic thrown by any handler in the stack, you need to include the Recover middleware below: Example package main import ( &quot;github.com/gofiber/fiber&quot; &quot;github.com/gofiber/fiber/middleware&quot; ) func main() { app := fiber.New() app.Use(middleware.Recover()) app.Get(&quot;/&quot;, func(c *fiber.Ctx) { panic(&quot;This panic is catched by the ErrorHandler&quot;) }) log.Fatal(app.Listen(3000)) }  Because ctx.Next() accepts an error interface, you could use Fiber's custom error struct to pass an additional status code using fiber.NewError(). It's optional to pass a message; if this is left empty, it will default to the status code message (404 equals Not Found). Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { err := fiber.NewError(503) c.Next(err) // 503 Service Unavailable err := fiber.NewError(404, &quot;Sorry, not found!&quot;) c.Next(err) // 404 Sorry, not found! })  "},{"title":"Default Error Handler​","type":1,"pageTitle":"🐛 Error Handling","url":"/v1.x/guide/error-handling#default-error-handler","content":"Fiber provides an error handler by default. For a standard error, the response is sent as 500 Internal Server Error. If error is of type fiber*Error, response is sent with the provided status code and message. Example // Default error handler app.Settings.ErrorHandler = func(ctx *fiber.Ctx, err error) { // Statuscode defaults to 500 code := fiber.StatusInternalServerError // Check if it's an fiber.Error type if e, ok := err.(*fiber.Error); ok { code = e.Code } // Return HTTP response ctx.Set(fiber.HeaderContentType, fiber.MIMETextPlainCharsetUTF8) ctx.Status(code).SendString(err.Error()) }  "},{"title":"Custom Error Handler​","type":1,"pageTitle":"🐛 Error Handling","url":"/v1.x/guide/error-handling#custom-error-handler","content":"A custom error handler can be set via app.Settings.ErrorHandler In most cases, the default error handler should be sufficient. However, a custom error handler can come in handy if you want to capture different types of errors and take action accordingly e.g., send a notification email or log an error to the centralized system. You can also send customized responses to the client e.g., error page or just a JSON response. The following example shows how to display error pages for different types of errors. Example app := fiber.New() // Custom error handler app.Settings.ErrorHandler = func(ctx *fiber.Ctx, err error) { // Statuscode defaults to 500 code := fiber.StatusInternalServerError // Retrieve the custom statuscode if it's an fiber.*Error if e, ok := err.(*fiber.Error); ok { code = e.Code } // Send custom error page err = ctx.Status(code).SendFile(fmt.Sprintf(&quot;./%d.html&quot;, code)) if err != nil { ctx.Status(500).SendString(&quot;Internal Server Error&quot;) } }  Special thanks to the Echo &amp; Express framework for inspiration regarding error handling. "},{"title":"🎭 Grouping","type":0,"sectionRef":"#","url":"/v1.x/guide/grouping","content":"","keywords":""},{"title":"Paths​","type":1,"pageTitle":"🎭 Grouping","url":"/v1.x/guide/grouping#paths","content":"Like Routing, groups can also have paths that belong to a cluster. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, cors()) // /api v1 := api.Group(&quot;/v1&quot;, mysql()) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, mongodb()) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user app.Listen(3000) }  A Group of paths can have an optional handler. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;) // /api v1 := api.Group(&quot;/v1&quot;) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user app.Listen(3000) }  caution Running /api, /v1 or /v2 will result in 404 error, make sure you have the errors set. "},{"title":"Group Handlers​","type":1,"pageTitle":"🎭 Grouping","url":"/v1.x/guide/grouping#group-handlers","content":"Group handlers can also be used as a routing path but they must have Next added to them so that the flow can continue. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;) // /api v1 := api.Group(&quot;/v1&quot;, func(c *fiber.Ctx) { c.JSON(fiber.Map{ &quot;message&quot;: &quot;v1&quot;, }) c.Next() }) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user app.Listen(3000) }  "},{"title":"🔌 Routing","type":0,"sectionRef":"#","url":"/v1.x/guide/routing","content":"","keywords":""},{"title":"Paths​","type":1,"pageTitle":"🔌 Routing","url":"/v1.x/guide/routing#paths","content":"Route paths, combined with a request method, define the endpoints at which requests can be made. Route paths can be strings or string patterns. Examples of route paths based on strings // This route path will match requests to the root route, &quot;/&quot;: app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Send(&quot;root&quot;) }) // This route path will match requests to &quot;/about&quot;: app.Get(&quot;/about&quot;, func(c *fiber.Ctx) { c.Send(&quot;about&quot;) }) // This route path will match requests to &quot;/random.txt&quot;: app.Get(&quot;/random.txt&quot;, func(c *fiber.Ctx) { c.Send(&quot;random.txt&quot;) })  "},{"title":"Parameters​","type":1,"pageTitle":"🔌 Routing","url":"/v1.x/guide/routing#parameters","content":"Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The obtained values can be retrieved using the Params function, with the name of the route parameter specified in the path as their respective keys. info The name of the route parameter must be made up of characters ([A-Za-z0-9_]). Example of define routes with route parameters // Parameters app.Get(&quot;/user/:name/books/:title&quot;, func(c *fiber.Ctx) { c.Write(c.Params(&quot;name&quot;)) c.Write(c.Params(&quot;title&quot;)) }) // Wildcard app.Get(&quot;/user/*&quot;, func(c *fiber.Ctx) { c.Send(c.Params(&quot;*&quot;)) }) // Optional parameter app.Get(&quot;/user/:name?&quot;, func(c *fiber.Ctx) { c.Send(c.Params(&quot;name&quot;)) })  info Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes. // http://localhost:3000/plantae/prunus.persica app.Get(&quot;/plantae/:genus.:species&quot;, func(c *fiber.Ctx) { c.Params(&quot;genus&quot;) // prunus c.Params(&quot;species&quot;) // persica })  // http://localhost:3000/flights/LAX-SFO app.Get(&quot;/flights/:from-:to&quot;, func(c *fiber.Ctx) { c.Params(&quot;from&quot;) // LAX c.Params(&quot;to&quot;) // SFO })  "},{"title":"Middleware​","type":1,"pageTitle":"🔌 Routing","url":"/v1.x/guide/routing#middleware","content":"Functions that are designed to make changes to the request or response are called middleware functions. The Next is a Fiber router function, when called, executes the next function that matches the current route. Example of a middleware function app.Use(func(c *fiber.Ctx) { // Set some security headers: c.Set(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;) c.Set(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;) c.Set(&quot;X-Download-Options&quot;, &quot;noopen&quot;) c.Set(&quot;Strict-Transport-Security&quot;, &quot;max-age=5184000&quot;) c.Set(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;) c.Set(&quot;X-DNS-Prefetch-Control&quot;, &quot;off&quot;) // Go to next middleware: c.Next() // End of the chain fmt.Println(&quot;Bye 👋!&quot;) }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Send(&quot;Hello, World!&quot;) })  Use method path is a mount, or prefix path, and limits middleware to only apply to any paths requested that begin with it. "},{"title":"Grouping​","type":1,"pageTitle":"🔌 Routing","url":"/v1.x/guide/routing#grouping","content":"If you have many endpoints, you can organize your routes using Group. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, cors()) // /api v1 := api.Group(&quot;/v1&quot;, mysql()) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, mongodb()) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user app.Listen(3000) }  "},{"title":"📝 Templates","type":0,"sectionRef":"#","url":"/v1.x/guide/templates","content":"","keywords":""},{"title":"Template interfaces​","type":1,"pageTitle":"📝 Templates","url":"/v1.x/guide/templates#template-interfaces","content":"Fiber provides a Views interface to provide your own template engine: Views type Views interface { Load() error Render(io.Writer, string, interface{}, ...string) error }  Views interface contains a Load and Render method, Load is executed by Fiber on app initialization to load/parse the templates. // Pass engine to Fiber's Views Engine app := fiber.New(&amp;fiber.Settings{ Views: engine, })  The Render method is linked to the ctx.Render() function that accepts a template name and binding data. app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Render(&quot;index&quot;, fiber.Map{ &quot;hello&quot;: &quot;world&quot;, }); })  "},{"title":"Engines​","type":1,"pageTitle":"📝 Templates","url":"/v1.x/guide/templates#engines","content":"Fiber team maintains templates package that provides wrappers for multiple template engines: htmlaceamberdjangohandlebarsjetmustachepug Exampleviews/index.html package main import ( &quot;github.com/gofiber/fiber&quot; &quot;github.com/gofiber/template/html&quot; ) func main() { // Initialize standard Go html template engine engine := html.New(&quot;./views&quot;, &quot;.html&quot;) app := fiber.New(&amp;fiber.Settings{ Views: engine, }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Render index template _ = c.Render(&quot;index&quot;, fiber.Map{ &quot;Title&quot;: &quot;Hello, World!&quot;, }) }) app.Listen(3000) }  "},{"title":"🔎 Validating","type":0,"sectionRef":"#","url":"/v1.x/guide/validating","content":"","keywords":""},{"title":"Validator package​","type":1,"pageTitle":"🔎 Validating","url":"/v1.x/guide/validating#validator-package","content":"Fiber can make great use of the validator package to ensure correct validation of data to store. Official validator Github page (Installation, use, examples..). You can find the detailed descriptions of the validations used in the fields contained on the structs below: Detailed docs Validation Example type Job struct{ Type string `validate:&quot;required,min=3,max=32&quot;` Salary int `validate:&quot;required,number&quot;` } type User struct{ Name string `validate:&quot;required,min=3,max=32&quot;` IsActive bool `validate:&quot;required,eq=True|eq=False&quot;` Email string `validate:&quot;required,email,min=6,max=32&quot;` Job Job `validate:&quot;dive&quot;` } type ErrorResponse struct { FailedField string Tag string Value string } func ValidateStruct(user User) []*ErrorResponse { var errors []*ErrorResponse validate = validator.New() err := validate.Struct(user) if err != nil { for _, err := range err.(validator.ValidationErrors) { var element ErrorResponse element.FailedField = err.StructNamespace() element.Tag = err.Tag() element.Value = err.Param() errors = append(errors, &amp;element) } } return errors } func AddUser(c *fiber.Ctx) { //Connect to database user := new(User) if err := c.BodyParser(user); err != nil { errors := ValidateStruct() if errors != nil { c.JSON(errors) return } } //Do something else here //Return user c.JSON(user) } // Running a test with the following curl commands // curl -X POST -H &quot;Content-Type: application/json&quot; --data &quot;{\\&quot;name\\&quot;:\\&quot;john\\&quot;,\\&quot;isactive\\&quot;:\\&quot;True\\&quot;}&quot; http://localhost:8080/register/user // Results in // [{&quot;FailedField&quot;:&quot;User.Email&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;},{&quot;FailedField&quot;:&quot;User.Job.Salary&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;},{&quot;FailedField&quot;:&quot;User.Job.Type&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;}]⏎  "},{"title":"📊 Benchmarks","type":0,"sectionRef":"#","url":"/v1.x/misc/benchmarks","content":"","keywords":""},{"title":"TechEmpower​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#techempower","content":"TechEmpower provides a performance comparison of many web application frameworks executing fundamental tasks such as JSON serialization, database access, and server-side template composition. Each framework is operating in a realistic production configuration. Results are captured on cloud instances and on physical hardware. The test implementations are largely community-contributed and all source is available at the GitHub repository. Fiber v1.10.028 HT Cores Intel(R) Xeon(R) Gold 5120 CPU @ 2.20GHz32GB RAMUbuntu 18.04.3 4.15.0-88-genericDedicated Cisco 10-Gbit Ethernet switch. "},{"title":"Plaintext​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#plaintext","content":"The Plaintext test is an exercise of the request-routing fundamentals only, designed to demonstrate the capacity of high-performance platforms in particular. Requests will be sent using HTTP pipelining. The response payload is still small, meaning good performance is still necessary in order to saturate the gigabit Ethernet of the test environment. See Plaintext requirements Fiber - 6,162,556 responses per second with an average latency of 2.0 ms. Express - 367,069 responses per second with an average latency of 354.1 ms.   "},{"title":"Data Updates​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#data-updates","content":"Fiber handled 11,846 responses per second with an average latency of 42.8 ms. Express handled 2,066 responses per second with an average latency of 390.44 ms.   "},{"title":"Multiple Queries​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#multiple-queries","content":"Fiber handled 19,664 responses per second with an average latency of 25.7 ms. Express handled 4,302 responses per second with an average latency of 117.2 ms.   "},{"title":"Single Query​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#single-query","content":"Fiber handled 368,647 responses per second with an average latency of 0.7 ms. Express handled 57,880 responses per second with an average latency of 4.4 ms.   "},{"title":"JSON Serialization​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#json-serialization","content":"Fiber handled 1,146,667 responses per second with an average latency of 0.4 ms. Express handled 244,847 responses per second with an average latency of 1.1 ms.   "},{"title":"Go web framework benchmark​","type":1,"pageTitle":"📊 Benchmarks","url":"/v1.x/misc/benchmarks#go-web-framework-benchmark","content":"🔗 https://github.com/smallnest/go-web-framework-benchmark CPU Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHzMEM 4GBGO go1.13.6 linux/amd64OS Linux The first test case is to mock 0 ms, 10 ms, 100 ms, 500 ms processing time in handlers.  The concurrency clients are 5000.  Latency is the time of real processing time by web servers. The smaller is the better.  Allocs is the heap allocations by web servers when test is running. The unit is MB. The smaller is the better. If we enable http pipelining, test result as below:  Concurrency test in 30 ms processing time, the test result for 100, 1000, 5000 clients is:    If we enable http pipelining, test result as below:  Dependency graph for v1.9.0  "},{"title":"🤔 FAQ","type":0,"sectionRef":"#","url":"/v1.x/misc/faq","content":"","keywords":""},{"title":"How should I structure my application?​","type":1,"pageTitle":"🤔 FAQ","url":"/v1.x/misc/faq#how-should-i-structure-my-application","content":"There is no definitive answer to this question. The answer depends on the scale of your application and the team that is involved. To be as flexible as possible, Fiber makes no assumptions in terms of structure. Routes and other application-specific logic can live in as many files as you wish, in any directory structure you prefer. View the following examples for inspiration: gofiber/boilerplatethomasvvugt/fiber-boilerplateYoutube - Building a REST API using Gorm and Fiber "},{"title":"How do I handle custom 404 responses?​","type":1,"pageTitle":"🤔 FAQ","url":"/v1.x/misc/faq#how-do-i-handle-custom-404-responses","content":"In Fiber, 404 responses are not the result of an error, so the error handler will not capture them. This behavior is because a 404 response simply indicates the absence of additional work to do; in other words, Fiber has found no routes that match the request. All you need to do is add a middleware function at the very bottom of the stack (below all other functions) to handle a 404 response: Example app.Use(func(c *fiber.Ctx) { c.Status(fiber.StatusNotFound).SendString(&quot;Sorry can't find that!&quot;) })  "},{"title":"How do I set up an error handler?​","type":1,"pageTitle":"🤔 FAQ","url":"/v1.x/misc/faq#how-do-i-set-up-an-error-handler","content":"To override the default error handler, provide a custom handler to the app.Settings.ErrorHandler Example app.Settings.ErrorHandler = func(c *fiber.Ctx, err error) { c.Status(500).SendString(err.Error()) }  We have a dedicated page explaining how error handling works in Fiber, see Error Handling. "},{"title":"Which template engines does Fiber support?​","type":1,"pageTitle":"🤔 FAQ","url":"/v1.x/misc/faq#which-template-engines-does-fiber-support","content":"Fiber currently supports 8 template engines in our gofiber/template middleware: AceAmberDjangoHandlebarsHTMLJetMustachePug To learn more about using Templates in Fiber, see Templates. "},{"title":"Does Fiber have a community chat?​","type":1,"pageTitle":"🤔 FAQ","url":"/v1.x/misc/faq#does-fiber-have-a-community-chat","content":"Yes, we have our own Discord server, where we hang out. We have different rooms for every subject. If you have questions or just want to have a chat, feel free to join us via this &gt; invite link &lt;.  "},{"title":"🧠 Ctx","type":0,"sectionRef":"#","url":"/v1.x/api/ctx","content":"","keywords":""},{"title":"Accepts​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#accepts","content":"Checks, if the specified extensions or content types are acceptable. info Based on the request’s Accept HTTP header. Signature c.Accepts(types ...string) string c.AcceptsCharsets(charsets ...string) string c.AcceptsEncodings(encodings ...string) string c.AcceptsLanguages(langs ...string) string  Example // Accept: text/*, application/json app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Accepts(&quot;html&quot;) // &quot;html&quot; c.Accepts(&quot;text/html&quot;) // &quot;text/html&quot; c.Accepts(&quot;json&quot;, &quot;text&quot;) // &quot;json&quot; c.Accepts(&quot;application/json&quot;) // &quot;application/json&quot; c.Accepts(&quot;image/png&quot;) // &quot;&quot; c.Accepts(&quot;png&quot;) // &quot;&quot; })  Fiber provides similar functions for the other accept headers. // Accept-Charset: utf-8, iso-8859-1;q=0.2 // Accept-Encoding: gzip, compress;q=0.2 // Accept-Language: en;q=0.8, nl, ru app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.AcceptsCharsets(&quot;utf-16&quot;, &quot;iso-8859-1&quot;) // &quot;iso-8859-1&quot; c.AcceptsEncodings(&quot;compress&quot;, &quot;br&quot;) // &quot;compress&quot; c.AcceptsLanguages(&quot;pt&quot;, &quot;nl&quot;, &quot;ru&quot;) // &quot;nl&quot; })  "},{"title":"Append​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#append","content":"Appends the specified value to the HTTP response header field. caution If the header is not already set, it creates the header with the specified value. Signature c.Append(field, values ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Append(&quot;Link&quot;, &quot;http://google.com&quot;, &quot;http://localhost&quot;) // =&gt; Link: http://localhost, http://google.com c.Append(&quot;Link&quot;, &quot;Test&quot;) // =&gt; Link: http://localhost, http://google.com, Test })  "},{"title":"Attachment​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#attachment","content":"Sets the HTTP response Content-Disposition header field to attachment. Signature c.Attachment(file ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Attachment() // =&gt; Content-Disposition: attachment c.Attachment(&quot;./upload/images/logo.png&quot;) // =&gt; Content-Disposition: attachment; filename=&quot;logo.png&quot; // =&gt; Content-Type: image/png })  "},{"title":"App​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#app","content":"Returns the *App reference so you could easily access all application settings. Signature c.App() *App  Example app.Get(&quot;/bodylimit&quot;, func(c *fiber.Ctx) { bodylimit := c.App().Settings.BodyLimit c.Send(bodylimit) })  "},{"title":"BaseURL​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#baseurl","content":"Returns the base URL (protocol + host) as a string. Signature c.BaseURL() string  Example // GET https://example.com/page#chapter-1 app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.BaseURL() // https://example.com })  "},{"title":"Body​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#body","content":"Returns the request body. Signature c.Body() string  Example // curl -X POST http://localhost:8080 -d user=john app.Post(&quot;/&quot;, func(c *fiber.Ctx) { // Get raw body from POST request: c.Body() // user=john })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"BodyParser​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#bodyparser","content":"Binds the request body to a struct. BodyParser supports decoding query parameters and the following content types based on the Content-Type header: application/jsonapplication/xmlapplication/x-www-form-urlencodedmultipart/form-data Signature c.BodyParser(out interface{}) error  Example // Field names should start with an uppercase letter type Person struct { Name string `json:&quot;name&quot; xml:&quot;name&quot; form:&quot;name&quot;` Pass string `json:&quot;pass&quot; xml:&quot;pass&quot; form:&quot;pass&quot;` } app.Post(&quot;/&quot;, func(c *fiber.Ctx) { p := new(Person) if err := c.BodyParser(p); err != nil { log.Fatal(err) } log.Println(p.Name) // john log.Println(p.Pass) // doe }) // Run tests with the following curl commands // curl -X POST -H &quot;Content-Type: application/json&quot; --data &quot;{\\&quot;name\\&quot;:\\&quot;john\\&quot;,\\&quot;pass\\&quot;:\\&quot;doe\\&quot;}&quot; localhost:3000 // curl -X POST -H &quot;Content-Type: application/xml&quot; --data &quot;&lt;login&gt;&lt;name&gt;john&lt;/name&gt;&lt;pass&gt;doe&lt;/pass&gt;&lt;/login&gt;&quot; localhost:3000 // curl -X POST -H &quot;Content-Type: application/x-www-form-urlencoded&quot; --data &quot;name=john&amp;pass=doe&quot; localhost:3000 // curl -X POST -F name=john -F pass=doe http://localhost:3000 // curl -X POST &quot;http://localhost:3000/?name=john&amp;pass=doe&quot;  "},{"title":"ClearCookie​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#clearcookie","content":"Expire a client cookie (or all cookies if left empty) Signature c.ClearCookie(key ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Clears all cookies: c.ClearCookie() // Expire specific cookie by name: c.ClearCookie(&quot;user&quot;) // Expire multiple cookies by names: c.ClearCookie(&quot;token&quot;, &quot;session&quot;, &quot;track_id&quot;, &quot;version&quot;) })  caution Web browsers and other compliant clients will only clear the cookie if the given options are identical to those when creating the cookie, excluding expires and maxAge. ClearCookie will not set these values for you - a technique similar to the one shown below should be used to ensure your cookie is deleted. Example app.Get(&quot;/set&quot;, func(c *fiber.Ctx) { c.Cookie(&amp;fiber.Cookie{ Name: &quot;token&quot;, Value: &quot;randomvalue&quot;, Expires: time.Now().Add(24 * time.Hour), HTTPOnly: true, SameSite: &quot;lax&quot;, }) }) app.Get(&quot;/delete&quot;, func(c *fiber.Ctx) { c.Cookie(&amp;fiber.Cookie{ Name: &quot;token&quot;, // Set expiry date to the past Expires: time.Now().Add(-(time.Hour * 2)), HTTPOnly: true, SameSite: &quot;lax&quot;, }) })  "},{"title":"Context​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#context","content":"Returns context.Context that carries a deadline, a cancellation signal, and other values across API boundaries. Signature c.Context() context.Context  "},{"title":"Cookie​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#cookie","content":"Set cookie Signature c.Cookie(*Cookie)  type Cookie struct { Name string Value string Path string Domain string Expires time.Time Secure bool HTTPOnly bool SameSite string // lax, strict, none }  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Create cookie cookie := new(fiber.Cookie) cookie.Name = &quot;john&quot; cookie.Value = &quot;doe&quot; cookie.Expires = time.Now().Add(24 * time.Hour) // Set cookie c.Cookie(cookie) })  "},{"title":"Cookies​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#cookies","content":"Get cookie value by key, you could pass an optional default value that will be returned if the cookie key does not exist. Signatures c.Cookies(key string, defaultValue ...string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Get cookie by key: c.Cookies(&quot;name&quot;) // &quot;john&quot; c.Cookies(&quot;empty&quot;, &quot;doe&quot;) // &quot;doe&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Download​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#download","content":"Transfers the file from path as an attachment. Typically, browsers will prompt the user to download. By default, the Content-Disposition header filename= parameter is the file path (this typically appears in the browser dialog). Override this default with the filename parameter. Signature c.Download(path, filename ...string) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { if err := c.Download(&quot;./files/report-12345.pdf&quot;); err != nil { c.Next(err) // Pass err to fiber } // =&gt; Download report-12345.pdf if err := c.Download(&quot;./files/report-12345.pdf&quot;, &quot;report.pdf&quot;); err != nil { c.Next(err) // Pass err to fiber } // =&gt; Download report.pdf })  "},{"title":"Fasthttp​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#fasthttp","content":"You can still access and use all Fasthttp methods and properties. Signature info Please read the Fasthttp Documentation for more information. Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Fasthttp.Request.Header.Method() // =&gt; []byte(&quot;GET&quot;) c.Fasthttp.Response.Write([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; })  "},{"title":"Error​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#error","content":"This contains the error information that thrown by a panic or passed via the Next(err) method. Signature c.Error() error  Example func main() { app := fiber.New() app.Post(&quot;/api/register&quot;, func (c *fiber.Ctx) { if err := c.JSON(&amp;User); err != nil { c.Next(err) } }) app.Get(&quot;/api/user&quot;, func (c *fiber.Ctx) { if err := c.JSON(&amp;User); err != nil { c.Next(err) } }) app.Put(&quot;/api/update&quot;, func (c *fiber.Ctx) { if err := c.JSON(&amp;User); err != nil { c.Next(err) } }) app.Use(&quot;/api&quot;, func(c *fiber.Ctx) { c.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) c.Status(500).Send(c.Error()) }) app.Listen(1337) }  "},{"title":"Format​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#format","content":"Performs content-negotiation on the Accept HTTP header. It uses Accepts to select a proper format. info If the header is not specified or there is no proper format, text/plain is used. Signature c.Format(body interface{})  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Accept: text/plain c.Format(&quot;Hello, World!&quot;) // =&gt; Hello, World! // Accept: text/html c.Format(&quot;Hello, World!&quot;) // =&gt; &lt;p&gt;Hello, World!&lt;/p&gt; // Accept: application/json c.Format(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; })  "},{"title":"FormFile​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#formfile","content":"MultipartForm files can be retrieved by name, the first file from the given key is returned. Signature c.FormFile(name string) (*multipart.FileHeader, error)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { // Get first file from form field &quot;document&quot;: file, err := c.FormFile(&quot;document&quot;) // Check for errors: if err == nil { // Save file to root directory: c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)) } })  "},{"title":"FormValue​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#formvalue","content":"Any form values can be retrieved by name, the first value from the given key is returned. Signature c.FormValue(name string) string  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { // Get first value from form field &quot;name&quot;: c.FormValue(&quot;name&quot;) // =&gt; &quot;john&quot; or &quot;&quot; if not exist })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Fresh​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#fresh","content":"https://expressjs.com/en/4x/api.html#req.fresh info Not implemented yet, pull requests are welcome! "},{"title":"Get​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#get","content":"Returns the HTTP request header specified by the field. tip The match is case-insensitive. Signature c.Get(field string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Get(&quot;Content-Type&quot;) // &quot;text/plain&quot; c.Get(&quot;CoNtEnT-TypE&quot;) // &quot;text/plain&quot; c.Get(&quot;something&quot;) // &quot;&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Hostname​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#hostname","content":"Returns the hostname derived from the Host HTTP header. Signature c.Hostname() string  Example // GET http://google.com/search app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Hostname() // &quot;google.com&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"IP​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#ip","content":"Returns the remote IP address of the request. Signature c.IP() string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.IP() // &quot;127.0.0.1&quot; })  "},{"title":"IPs​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#ips","content":"Returns an array of IP addresses specified in the X-Forwarded-For request header. Signature c.IPs() []string  Example // X-Forwarded-For: proxy1, 127.0.0.1, proxy3 app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.IPs() // [&quot;proxy1&quot;, &quot;127.0.0.1&quot;, &quot;proxy3&quot;] })  "},{"title":"Is​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#is","content":"Returns the matching content type, if the incoming request’s Content-Type HTTP header field matches the MIME type specified by the type parameter. info If the request has no body, it returns false. Signature c.Is(t string) bool  Example // Content-Type: text/html; charset=utf-8 app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Is(&quot;html&quot;) // true c.Is(&quot;.html&quot;) // true c.Is(&quot;json&quot;) // false })  "},{"title":"JSON​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#json","content":"Converts any interface or string to JSON using Jsoniter. info JSON also sets the content header to application/json. Signature c.JSON(v interface{}) error  Example type SomeStruct struct { Name string Age uint8 } app.Get(&quot;/json&quot;, func(c *fiber.Ctx) { // Create data struct: data := SomeStruct{ Name: &quot;Grame&quot;, Age: 20, } if err := c.JSON(data); err != nil { c.Status(500).Send(err) return } // =&gt; Content-Type: application/json // =&gt; &quot;{&quot;Name&quot;: &quot;Grame&quot;, &quot;Age&quot;: 20}&quot; if err := c.JSON(fiber.Map{ &quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20, }); err != nil { c.Status(500).Send(err) return } // =&gt; Content-Type: application/json // =&gt; &quot;{&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}&quot; })  "},{"title":"JSONP​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#jsonp","content":"Sends a JSON response with JSONP support. This method is identical to JSON, except that it opts-in to JSONP callback support. By default, the callback name is simply callback. Override this by passing a named string in the method. Signature c.JSONP(v interface{}, callback ...string) error  Example type SomeStruct struct { name string age uint8 } app.Get(&quot;/&quot;, func(c *fiber.Ctx) { // Create data struct: data := SomeStruct{ name: &quot;Grame&quot;, age: 20, } c.JSONP(data) // =&gt; callback({&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}) c.JSONP(data, &quot;customFunc&quot;) // =&gt; customFunc({&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}) })  "},{"title":"Links​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#links","content":"Joins the links followed by the property to populate the response’s Link HTTP header field. Signature c.Links(link ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Link( &quot;http://api.example.com/users?page=2&quot;, &quot;next&quot;, &quot;http://api.example.com/users?page=5&quot;, &quot;last&quot;, ) // Link: &lt;http://api.example.com/users?page=2&gt;; rel=&quot;next&quot;, // &lt;http://api.example.com/users?page=5&gt;; rel=&quot;last&quot; })  "},{"title":"Locals​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#locals","content":"A method that stores variables scoped to the request and, therefore, are available only to the routes that match the request. tip This is useful if you want to pass some specific data to the next middleware. Signature c.Locals(key string, value ...interface{}) interface{}  Example app.Use(func(c *fiber.Ctx) { c.Locals(&quot;user&quot;, &quot;admin&quot;) c.Next() }) app.Get(&quot;/admin&quot;, func(c *fiber.Ctx) { if c.Locals(&quot;user&quot;) == &quot;admin&quot; { c.Status(200).Send(&quot;Welcome, admin!&quot;) } else { c.SendStatus(403) // =&gt; 403 Forbidden } })  "},{"title":"Location​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#location","content":"Sets the response Location HTTP header to the specified path parameter. Signature c.Location(path string)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { c.Location(&quot;http://example.com&quot;) c.Location(&quot;/foo/bar&quot;) })  "},{"title":"Method​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#method","content":"Returns a string corresponding to the HTTP method of the request: GET, POST, PUT, and so on. Optionally, you could override the method by passing a string. Signature c.Method(override ...string) string  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { c.Method() // &quot;POST&quot; })  "},{"title":"MultipartForm​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#multipartform","content":"To access multipart form entries, you can parse the binary with MultipartForm(). This returns a map[string][]string, so given a key, the value will be a string slice. Signature c.MultipartForm() (*multipart.Form, error)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { // Parse the multipart form: if form, err := c.MultipartForm(); err == nil { // =&gt; *multipart.Form if token := form.Value[&quot;token&quot;]; len(token) &gt; 0 { // Get key value: fmt.Println(token[0]) } // Get all files from &quot;documents&quot; key: files := form.File[&quot;documents&quot;] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[&quot;Content-Type&quot;][0]) // =&gt; &quot;tutorial.pdf&quot; 360641 &quot;application/pdf&quot; // Save the files to disk: c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)) } } })  "},{"title":"Next​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#next","content":"When Next is called, it executes the next method in the stack that matches the current route. You can pass an error struct within the method that will end the chaining and call the error handler. Signature c.Next(err ...error)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { fmt.Println(&quot;1st route!&quot;) c.Next() }) app.Get(&quot;*&quot;, func(c *fiber.Ctx) { fmt.Println(&quot;2nd route!&quot;) c.Next() }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) { fmt.Println(&quot;3rd route!&quot;) c.Send(&quot;Hello, World!&quot;) })  "},{"title":"OriginalURL​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#originalurl","content":"Returns the original request URL. Signature c.OriginalURL() string  Example // GET http://example.com/search?q=something app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.OriginalURL() // &quot;/search?q=something&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Params​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#params","content":"Method can be used to get the route parameters, you could pass an optional default value that will be returned if the param key does not exist. info Defaults to empty string (&quot;&quot;), if the param doesn't exist. Signature c.Params(param string, defaultValue ...string) string  Example // GET http://example.com/user/fenny app.Get(&quot;/user/:name&quot;, func(c *fiber.Ctx) { c.Params(&quot;name&quot;) // &quot;fenny&quot; c.Params(&quot;age&quot;, &quot;21&quot;) // &quot;21&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more...__ "},{"title":"Path​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#path","content":"Contains the path part of the request URL. Optionally, you could override the path by passing a string. Signature c.Path(override ...string) string  Example // GET http://example.com/users?sort=desc app.Get(&quot;/users&quot;, func(c *fiber.Ctx) { c.Path() // &quot;/users&quot; })  "},{"title":"Protocol​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#protocol","content":"Contains the request protocol string: http or https for TLS requests. Signature c.Protocol() string  Example // GET http://example.com app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Protocol() // &quot;http&quot; })  "},{"title":"Query​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#query","content":"This property is an object containing a property for each query string parameter in the route, you could pass an optional default value that will be returned if the query key does not exist. info If there is no query string, it returns an empty string. Signature c.Query(parameter string, defaultValue ...string) string  Example // GET http://example.com/shoes?order=desc&amp;brand=nike app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Query(&quot;order&quot;) // &quot;desc&quot; c.Query(&quot;brand&quot;) // &quot;nike&quot; c.Query(&quot;empty&quot;, &quot;nike&quot;) // &quot;nike&quot; })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"QueryParser​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#queryparser","content":"This method is similar to BodyParser, but for query parameters. Signature c.QueryParser(out interface{}) error  Example // Field names should start with an uppercase letter type Person struct { Name string `query:&quot;name&quot;` Pass string `query:&quot;pass&quot;` Products []string `query:&quot;products&quot;` } app.Post(&quot;/&quot;, func(c *fiber.Ctx) { p := new(Person) if err := c.QueryParser(p); err != nil { log.Fatal(err) } log.Println(p.Name) // john log.Println(p.Pass) // doe log.Println(p.Products) // [shoe, hat] }) // Run tests with the following curl command // curl -X POST &quot;http://localhost:3000/?name=john&amp;pass=doe&amp;products=shoe,hat&quot;  "},{"title":"Range​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#range","content":"A struct containing the type and a slice of ranges will be returned. Signature c.Range(int size)  Example // Range: bytes=500-700, 700-900 app.Get(&quot;/&quot;, func(c *fiber.Ctx) { b := c.Range(1000) if b.Type == &quot;bytes&quot; { for r := range r.Ranges { fmt.Println(r) // [500, 700] } } })  "},{"title":"Redirect​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#redirect","content":"Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an HTTP status code. info If not specified, status defaults to 302 Found. Signature c.Redirect(path string, status ...int)  Example app.Get(&quot;/coffee&quot;, func(c *fiber.Ctx) { c.Redirect(&quot;/teapot&quot;) }) app.Get(&quot;/teapot&quot;, func(c *fiber.Ctx) { c.Status(fiber.StatusTeapot).Send(&quot;🍵 short and stout 🍵&quot;) })  More examples app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Redirect(&quot;/foo/bar&quot;) c.Redirect(&quot;../login&quot;) c.Redirect(&quot;http://example.com&quot;) c.Redirect(&quot;http://example.com&quot;, 301) })  "},{"title":"Render​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#render","content":"Renders a view with data and sends a text/html response. By default Render uses the default Go Template engine. If you want to use another View engine, please take a look at our Template middleware. Signature c.Render(file string, data interface{}, layout ...string) error  "},{"title":"Route​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#route","content":"Returns the matched Route struct. Signature c.Route() *Route  Example // http://localhost:8080/hello handler := func(c *fiber.Ctx) { r := c.Route() fmt.Println(r.Method, r.Path, r.Params, r.Handlers) // GET /hello/:name handler [name] } app.Get(&quot;/hello/:name&quot;, handler )  "},{"title":"SaveFile​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#savefile","content":"Method is used to save any multipart file to disk. Signature c.SaveFile(fh *multipart.FileHeader, path string)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) { // Parse the multipart form: if form, err := c.MultipartForm(); err == nil { // =&gt; *multipart.Form // Get all files from &quot;documents&quot; key: files := form.File[&quot;documents&quot;] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[&quot;Content-Type&quot;][0]) // =&gt; &quot;tutorial.pdf&quot; 360641 &quot;application/pdf&quot; // Save the files to disk: c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)) } } })  "},{"title":"Secure​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#secure","content":"A boolean property that is true , if a TLS connection is established. Signature c.Secure() bool  Example // Secure() method is equivalent to: c.Protocol() == &quot;https&quot;  "},{"title":"Send​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#send","content":"Sets the HTTP response body. The Send body can be of any type. caution Send doesn't append like the Write method. Signature c.Send(body ...interface{})  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Send(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; c.Send([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; c.Send(123) // =&gt; 123 })  Fiber also provides SendBytes ,SendString and SendStream methods for raw inputs. tip Use this if you don't need type assertion, recommended for faster performance. Signature c.SendBytes(b []byte) c.SendString(s string) c.SendStream(r io.Reader, s ...int)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.SendByte([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; c.SendString(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; c.SendStream(bytes.NewReader([]byte(&quot;Hello, World!&quot;))) // =&gt; &quot;Hello, World!&quot; })  "},{"title":"SendFile​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#sendfile","content":"Transfers the file from the given path. Sets the Content-Type response HTTP header field based on the filenames extension. caution Method use gzipping by default, set it to true to disable. Signature c.SendFile(path string, compress ...bool) error  Example app.Get(&quot;/not-found&quot;, func(c *fiber.Ctx) { if err := c.SendFile(&quot;./public/404.html&quot;); err != nil { c.Next(err) // pass err to ErrorHandler } // Enable compression if err := c.SendFile(&quot;./static/index.html&quot;, true); err != nil { c.Next(err) // pass err to ErrorHandler } })  "},{"title":"SendStatus​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#sendstatus","content":"Sets the status code and the correct status message in the body, if the response body is empty. tip You can find all used status codes and messages here. Signature c.SendStatus(status int)  Example app.Get(&quot;/not-found&quot;, func(c *fiber.Ctx) { c.SendStatus(415) // =&gt; 415 &quot;Unsupported Media Type&quot; c.Send(&quot;Hello, World!&quot;) c.SendStatus(415) // =&gt; 415 &quot;Hello, World!&quot; })  "},{"title":"Set​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#set","content":"Sets the response’s HTTP header field to the specified key, value. Signature c.Set(field, value string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Set(&quot;Content-Type&quot;, &quot;text/plain&quot;) // =&gt; &quot;Content-type: text/plain&quot; })  "},{"title":"Stale​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#stale","content":"https://expressjs.com/en/4x/api.html#req.fresh info Not implemented yet, pull requests are welcome! "},{"title":"Status​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#status","content":"Sets the HTTP status for the response. info Method is a chainable. Signature c.Status(status int)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Status(200) c.Status(400).Send(&quot;Bad Request&quot;) c.Status(404).SendFile(&quot;./public/gopher.png&quot;) })  "},{"title":"Subdomains​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#subdomains","content":"Returns a string slice of subdomains in the domain name of the request. The application property subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments. Signature c.Subdomains(offset ...int) []string  Example // Host: &quot;tobi.ferrets.example.com&quot; app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Subdomains() // [&quot;ferrets&quot;, &quot;tobi&quot;] c.Subdomains(1) // [&quot;tobi&quot;] })  "},{"title":"Type​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#type","content":"Sets the Content-Type HTTP header to the MIME type listed here specified by the file extension. Signature c.Type(t string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Type(&quot;.html&quot;) // =&gt; &quot;text/html&quot; c.Type(&quot;html&quot;) // =&gt; &quot;text/html&quot; c.Type(&quot;json&quot;) // =&gt; &quot;application/json&quot; c.Type(&quot;png&quot;) // =&gt; &quot;image/png&quot; })  "},{"title":"Vary​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#vary","content":"Adds the given header field to the Vary response header. This will append the header, if not already listed, otherwise leaves it listed in the current location. info Multiple fields are allowed. Signature c.Vary(field ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Vary(&quot;Origin&quot;) // =&gt; Vary: Origin c.Vary(&quot;User-Agent&quot;) // =&gt; Vary: Origin, User-Agent // No duplicates c.Vary(&quot;Origin&quot;) // =&gt; Vary: Origin, User-Agent c.Vary(&quot;Accept-Encoding&quot;, &quot;Accept&quot;) // =&gt; Vary: Origin, User-Agent, Accept-Encoding, Accept })  "},{"title":"Write​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#write","content":"Appends any input to the HTTP body response. Signature c.Write(body ...interface{})  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.Write(&quot;Hello, &quot;) // =&gt; &quot;Hello, &quot; c.Write([]byte(&quot;World! &quot;)) // =&gt; &quot;Hello, World! &quot; c.Write(123) // =&gt; &quot;Hello, World! 123&quot; })  "},{"title":"XHR​","type":1,"pageTitle":"🧠 Ctx","url":"/v1.x/api/ctx#xhr","content":"A Boolean property, that is true, if the request’s X-Requested-With header field is XMLHttpRequest, indicating that the request was issued by a client library (such as jQuery). Signature c.XHR() bool  Example // X-Requested-With: XMLHttpRequest app.Get(&quot;/&quot;, func(c *fiber.Ctx) { c.XHR() // true })  "},{"title":"🚀 App","type":0,"sectionRef":"#","url":"/api/app","content":"","keywords":""},{"title":"Static​","type":1,"pageTitle":"🚀 App","url":"/api/app#static","content":"Use the Static method to serve static files such as images, CSS, and JavaScript. info By default, Static will serve index.html files in response to a request on a directory. Signature func (app *App) Static(prefix, root string, config ...Static) Router  Use the following code to serve files in a directory named ./public app.Static(&quot;/&quot;, &quot;./public&quot;) // =&gt; http://localhost:3000/hello.html // =&gt; http://localhost:3000/js/jquery.js // =&gt; http://localhost:3000/css/style.css  Examples // Serve files from multiple directories app.Static(&quot;/&quot;, &quot;./public&quot;) // Serve files from &quot;./files&quot; directory: app.Static(&quot;/&quot;, &quot;./files&quot;)  You can use any virtual path prefix (where the path does not actually exist in the file system) for files that are served by the Static method, specify a prefix path for the static directory, as shown below: Examples app.Static(&quot;/static&quot;, &quot;./public&quot;) // =&gt; http://localhost:3000/static/hello.html // =&gt; http://localhost:3000/static/js/jquery.js // =&gt; http://localhost:3000/static/css/style.css  If you want to have a little bit more control regarding the settings for serving static files. You could use the fiber.Static struct to enable specific settings. fiber.Static{} // Static defines configuration options when defining static assets. type Static struct { // When set to true, the server tries minimizing CPU usage by caching compressed files. // This works differently than the github.com/gofiber/compression middleware. // Optional. Default value false Compress bool `json:&quot;compress&quot;` // When set to true, enables byte range requests. // Optional. Default value false ByteRange bool `json:&quot;byte_range&quot;` // When set to true, enables directory browsing. // Optional. Default value false. Browse bool `json:&quot;browse&quot;` // When set to true, enables direct download. // Optional. Default value false. Download bool `json:&quot;download&quot;` // The name of the index file for serving a directory. // Optional. Default value &quot;index.html&quot;. Index string `json:&quot;index&quot;` // Expiration duration for inactive file handlers. // Use a negative time.Duration to disable it. // // Optional. Default value 10 * time.Second. CacheDuration time.Duration `json:&quot;cache_duration&quot;` // The value for the Cache-Control HTTP-header // that is set on the file response. MaxAge is defined in seconds. // // Optional. Default value 0. MaxAge int `json:&quot;max_age&quot;` // ModifyResponse defines a function that allows you to alter the response. // // Optional. Default: nil ModifyResponse Handler // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *Ctx) bool }  Example // Custom config app.Static(&quot;/&quot;, &quot;./public&quot;, fiber.Static{ Compress: true, ByteRange: true, Browse: true, Index: &quot;john.html&quot; CacheDuration: 10 * time.Second, MaxAge: 3600, })  "},{"title":"Route Handlers​","type":1,"pageTitle":"🚀 App","url":"/api/app#route-handlers","content":"Registeres a route bound to a specific HTTP method. Signatures // HTTP methods func (app *App) Get(path string, handlers ...Handler) Router func (app *App) Head(path string, handlers ...Handler) Router func (app *App) Post(path string, handlers ...Handler) Router func (app *App) Put(path string, handlers ...Handler) Router func (app *App) Delete(path string, handlers ...Handler) Router func (app *App) Connect(path string, handlers ...Handler) Router func (app *App) Options(path string, handlers ...Handler) Router func (app *App) Trace(path string, handlers ...Handler) Router func (app *App) Patch(path string, handlers ...Handler) Router // Add allows you to specifiy a method as value func (app *App) Add(method, path string, handlers ...Handler) Router // All will register the route on all HTTP methods // Almost the same as app.Use but not bound to prefixes func (app *App) All(path string, handlers ...Handler) Router  Examples // Simple GET handler app.Get(&quot;/api/list&quot;, func(c *fiber.Ctx)error{ return c.SendString(&quot;I'm a GET request!&quot;) }) // Simple POST handler app.Post(&quot;/api/register&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;I'm a POST request!&quot;) })  Use can be used for middleware packages and prefix catchers. These routes will only match the beginning of each path i.e. /john will match /john/doe, /johnnnnn etc Signature func (app *App) Use(args ...interface{}) Router  Examples // Match any request app.Use(func(c *fiber.Ctx) error { return c.Next() }) // Match request starting with /api app.Use(&quot;/api&quot;, func(c *fiber.Ctx) error { return c.Next() }) // Attach multiple handlers app.Use(&quot;/api&quot;,func(c *fiber.Ctx) error { c.Set(&quot;X-Custom-Header&quot;, random.String(32)) return c.Next() }, func(c *fiber.Ctx) error { return c.Next() })  "},{"title":"Mount​","type":1,"pageTitle":"🚀 App","url":"/api/app#mount","content":"You can Mount Fiber instance by creating a *Mount Signature func (a *App) Mount(prefix string, app *App) Router  Examples func main() { micro := fiber.New() micro.Get(&quot;/doe&quot;, func(c *fiber.Ctx) error { return c.SendStatus(fiber.StatusOK) }) app := fiber.New() app.Mount(&quot;/john&quot;, micro) // GET /john/doe -&gt; 200 OK log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"Group​","type":1,"pageTitle":"🚀 App","url":"/api/app#group","content":"You can group routes by creating a *Group struct. Signature func (app *App) Group(prefix string, handlers ...Handler) Router  Examples func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, handler) // /api v1 := api.Group(&quot;/v1&quot;, handler) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, handler) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"Route​","type":1,"pageTitle":"🚀 App","url":"/api/app#route","content":"You can define routes with a common prefix inside the common function. Signature func (app *App) Route(prefix string, fn func(router Router), name ...string) Router  Examples func main() { app := fiber.New() app.Route(&quot;/test&quot;, func(api fiber.Router) { api.Get(&quot;/foo&quot;, handler).Name(&quot;foo&quot;) // /test/foo (name: test.foo) api.Get(&quot;/bar&quot;, handler).Name(&quot;bar&quot;) // /test/bar (name: test.bar) }, &quot;test.&quot;) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"Server​","type":1,"pageTitle":"🚀 App","url":"/api/app#server","content":"Server returns the underlying fasthttp server Signature func (app *App) Server() *fasthttp.Server  Examples func main() { app := fiber.New() app.Server().MaxConnsPerIP = 1 // ... }  "},{"title":"HandlersCount​","type":1,"pageTitle":"🚀 App","url":"/api/app#handlerscount","content":"This method returns the amount of registered handlers. Signature func (app *App) HandlersCount() uint32  "},{"title":"Stack​","type":1,"pageTitle":"🚀 App","url":"/api/app#stack","content":"This method returns the original router stack Signature func (app *App) Stack() [][]*Route  Examples var handler = func(c *fiber.Ctx) error { return nil } func main() { app := fiber.New() app.Get(&quot;/john/:age&quot;, handler) app.Post(&quot;/register&quot;, handler) data, _ := json.MarshalIndent(app.Stack(), &quot;&quot;, &quot; &quot;) fmt.Println(string(data)) app.Listen(&quot;:3000&quot;) }  Result [ [ { &quot;method&quot;: &quot;GET&quot;, &quot;path&quot;: &quot;/john/:age&quot;, &quot;params&quot;: [ &quot;age&quot; ] } ], [ { &quot;method&quot;: &quot;HEAD&quot;, &quot;path&quot;: &quot;/john/:age&quot;, &quot;params&quot;: [ &quot;age&quot; ] } ], [ { &quot;method&quot;: &quot;POST&quot;, &quot;path&quot;: &quot;/register&quot;, &quot;params&quot;: null } ] ]  "},{"title":"Name​","type":1,"pageTitle":"🚀 App","url":"/api/app#name","content":"This method assigns the name of latest created route. Signature func (app *App) Name(name string) Router  Examples var handler = func(c *fiber.Ctx) error { return nil } func main() { app := fiber.New() app.Get(&quot;/&quot;, handler) app.Name(&quot;index&quot;) app.Get(&quot;/doe&quot;, handler).Name(&quot;home&quot;) app.Trace(&quot;/tracer&quot;, handler).Name(&quot;tracert&quot;) app.Delete(&quot;/delete&quot;, handler).Name(&quot;delete&quot;) a := app.Group(&quot;/a&quot;) a.Name(&quot;fd.&quot;) a.Get(&quot;/test&quot;, handler).Name(&quot;test&quot;) data, _ := json.MarshalIndent(app.Stack(), &quot;&quot;, &quot; &quot;) fmt.Print(string(data)) app.Listen(&quot;:3000&quot;) }  Result [ [ { &quot;method&quot;: &quot;GET&quot;, &quot;name&quot;: &quot;index&quot;, &quot;path&quot;: &quot;/&quot;, &quot;params&quot;: null }, { &quot;method&quot;: &quot;GET&quot;, &quot;name&quot;: &quot;home&quot;, &quot;path&quot;: &quot;/doe&quot;, &quot;params&quot;: null }, { &quot;method&quot;: &quot;GET&quot;, &quot;name&quot;: &quot;fd.test&quot;, &quot;path&quot;: &quot;/a/test&quot;, &quot;params&quot;: null } ], [ { &quot;method&quot;: &quot;HEAD&quot;, &quot;name&quot;: &quot;&quot;, &quot;path&quot;: &quot;/&quot;, &quot;params&quot;: null }, { &quot;method&quot;: &quot;HEAD&quot;, &quot;name&quot;: &quot;&quot;, &quot;path&quot;: &quot;/doe&quot;, &quot;params&quot;: null }, { &quot;method&quot;: &quot;HEAD&quot;, &quot;name&quot;: &quot;&quot;, &quot;path&quot;: &quot;/a/test&quot;, &quot;params&quot;: null } ], null, null, [ { &quot;method&quot;: &quot;DELETE&quot;, &quot;name&quot;: &quot;delete&quot;, &quot;path&quot;: &quot;/delete&quot;, &quot;params&quot;: null } ], null, null, [ { &quot;method&quot;: &quot;TRACE&quot;, &quot;name&quot;: &quot;tracert&quot;, &quot;path&quot;: &quot;/tracer&quot;, &quot;params&quot;: null } ], null ]  "},{"title":"GetRoute​","type":1,"pageTitle":"🚀 App","url":"/api/app#getroute","content":"This method gets the route by name. Signature func (app *App) GetRoute(name string) Route  Examples var handler = func(c *fiber.Ctx) error { return nil } func main() { app := fiber.New() app.Get(&quot;/&quot;, handler).Name(&quot;index&quot;) data, _ := json.MarshalIndent(app.GetRoute(&quot;index&quot;), &quot;&quot;, &quot; &quot;) fmt.Print(string(data)) app.Listen(&quot;:3000&quot;) }  Result { &quot;method&quot;: &quot;GET&quot;, &quot;name&quot;: &quot;index&quot;, &quot;path&quot;: &quot;/&quot;, &quot;params&quot;: null }  "},{"title":"GetRoutes​","type":1,"pageTitle":"🚀 App","url":"/api/app#getroutes","content":"This method gets all routes. Signature func (app *App) GetRoutes(filterUseOption ...bool) []Route  When filterUseOption equal to true, it will filter the routes registered by the middleware. Examples func main() { app := fiber.New() app.Post(&quot;/&quot;, func (c *fiber.Ctx) error { return c.SendString(&quot;Hello, World!&quot;) }).Name(&quot;index&quot;) data, _ := json.MarshalIndent(app.GetRoutes(true), &quot;&quot;, &quot; &quot;) fmt.Print(string(data)) }  Result [ { &quot;method&quot;: &quot;POST&quot;, &quot;name&quot;: &quot;index&quot;, &quot;path&quot;: &quot;/&quot;, &quot;params&quot;: null } ]  "},{"title":"Config​","type":1,"pageTitle":"🚀 App","url":"/api/app#config","content":"Config returns the app config as value ( read-only ). Signature func (app *App) Config() Config  "},{"title":"Handler​","type":1,"pageTitle":"🚀 App","url":"/api/app#handler","content":"Handler returns the server handler that can be used to serve custom *fasthttp.RequestCtx requests. Signature func (app *App) Handler() fasthttp.RequestHandler  "},{"title":"Listen​","type":1,"pageTitle":"🚀 App","url":"/api/app#listen","content":"Listen serves HTTP requests from the given address. Signature func (app *App) Listen(addr string) error  Examples // Listen on port :8080 app.Listen(&quot;:8080&quot;) // Custom host app.Listen(&quot;127.0.0.1:8080&quot;)  "},{"title":"ListenTLS​","type":1,"pageTitle":"🚀 App","url":"/api/app#listentls","content":"ListenTLS serves HTTPs requests from the given address using certFile and keyFile paths to as TLS certificate and key file. Signature func (app *App) ListenTLS(addr, certFile, keyFile string) error  Examples app.ListenTLS(&quot;:443&quot;, &quot;./cert.pem&quot;, &quot;./cert.key&quot;);  Using ListenTLS defaults to the following config ( use Listener to provide your own config ) Default *tls.Config &amp;tls.Config{ MinVersion: tls.VersionTLS12, Certificates: []tls.Certificate{ cert, }, }  "},{"title":"ListenMutualTLS​","type":1,"pageTitle":"🚀 App","url":"/api/app#listenmutualtls","content":"ListenMutualTLS serves HTTPs requests from the given address using certFile, keyFile and clientCertFile are the paths to TLS certificate and key file Signature func (app *App) ListenMutualTLS(addr, certFile, keyFile, clientCertFile string) error  Examples app.ListenMutualTLS(&quot;:443&quot;, &quot;./cert.pem&quot;, &quot;./cert.key&quot;, &quot;./ca-chain-cert.pem&quot;);  Using ListenMutualTLS defaults to the following config ( use Listener to provide your own config ) Default *tls.Config &amp;tls.Config{ MinVersion: tls.VersionTLS12, ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: clientCertPool, Certificates: []tls.Certificate{ cert, }, }  "},{"title":"Listener​","type":1,"pageTitle":"🚀 App","url":"/api/app#listener","content":"You can pass your own net.Listener using the Listener method. This method can be used to enable TLS/HTTPS with a custom tls.Config. Signature func (app *App) Listener(ln net.Listener) error  Examples ln, _ := net.Listen(&quot;tcp&quot;, &quot;:3000&quot;) cer, _:= tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;) ln = tls.NewListener(ln, &amp;tls.Config{Certificates: []tls.Certificate{cer}}) app.Listener(ln)  "},{"title":"Test​","type":1,"pageTitle":"🚀 App","url":"/api/app#test","content":"Testing your application is done with the Test method. Use this method for creating _test.go files or when you need to debug your routing logic. The default timeout is 1s if you want to disable a timeout altogether, pass -1 as a second argument. Signature func (app *App) Test(req *http.Request, msTimeout ...int) (*http.Response, error)  Examples // Create route with GET method for test: app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { fmt.Println(c.BaseURL()) // =&gt; http://google.com fmt.Println(c.Get(&quot;X-Custom-Header&quot;)) // =&gt; hi return c.SendString(&quot;hello, World!&quot;) }) // http.Request req := httptest.NewRequest(&quot;GET&quot;, &quot;http://google.com&quot;, nil) req.Header.Set(&quot;X-Custom-Header&quot;, &quot;hi&quot;) // http.Response resp, _ := app.Test(req) // Do something with results: if resp.StatusCode == fiber.StatusOK { body, _ := ioutil.ReadAll(resp.Body) fmt.Println(string(body)) // =&gt; Hello, World! }  "},{"title":"Hooks​","type":1,"pageTitle":"🚀 App","url":"/api/app#hooks","content":"Hooks is a method to return hooks property. Signature func (app *App) Hooks() *Hooks  "},{"title":"📋 Constants","type":0,"sectionRef":"#","url":"/api/constants","content":"📋 Constants HTTP methods were copied from net/http. const ( MethodGet = &quot;GET&quot; // RFC 7231, 4.3.1 MethodHead = &quot;HEAD&quot; // RFC 7231, 4.3.2 MethodPost = &quot;POST&quot; // RFC 7231, 4.3.3 MethodPut = &quot;PUT&quot; // RFC 7231, 4.3.4 MethodPatch = &quot;PATCH&quot; // RFC 5789 MethodDelete = &quot;DELETE&quot; // RFC 7231, 4.3.5 MethodConnect = &quot;CONNECT&quot; // RFC 7231, 4.3.6 MethodOptions = &quot;OPTIONS&quot; // RFC 7231, 4.3.7 MethodTrace = &quot;TRACE&quot; // RFC 7231, 4.3.8 methodUse = &quot;USE&quot; ) MIME types that are commonly used const ( MIMETextXML = &quot;text/xml&quot; MIMETextHTML = &quot;text/html&quot; MIMETextPlain = &quot;text/plain&quot; MIMEApplicationXML = &quot;application/xml&quot; MIMEApplicationJSON = &quot;application/json&quot; MIMEApplicationJavaScript = &quot;application/javascript&quot; MIMEApplicationForm = &quot;application/x-www-form-urlencoded&quot; MIMEOctetStream = &quot;application/octet-stream&quot; MIMEMultipartForm = &quot;multipart/form-data&quot; MIMETextXMLCharsetUTF8 = &quot;text/xml; charset=utf-8&quot; MIMETextHTMLCharsetUTF8 = &quot;text/html; charset=utf-8&quot; MIMETextPlainCharsetUTF8 = &quot;text/plain; charset=utf-8&quot; MIMEApplicationXMLCharsetUTF8 = &quot;application/xml; charset=utf-8&quot; MIMEApplicationJSONCharsetUTF8 = &quot;application/json; charset=utf-8&quot; MIMEApplicationJavaScriptCharsetUTF8 = &quot;application/javascript; charset=utf-8&quot; ) HTTP status codes were copied from net/http. const ( StatusContinue = 100 // RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusEarlyHints = 103 // RFC 8297 StatusOK = 200 // RFC 7231, 6.3.1 StatusCreated = 201 // RFC 7231, 6.3.2 StatusAccepted = 202 // RFC 7231, 6.3.3 StatusNonAuthoritativeInformation = 203 // RFC 7231, 6.3.4 StatusNoContent = 204 // RFC 7231, 6.3.5 StatusResetContent = 205 // RFC 7231, 6.3.6 StatusPartialContent = 206 // RFC 7233, 4.1 StatusMultiStatus = 207 // RFC 4918, 11.1 StatusAlreadyReported = 208 // RFC 5842, 7.1 StatusIMUsed = 226 // RFC 3229, 10.4.1 StatusMultipleChoices = 300 // RFC 7231, 6.4.1 StatusMovedPermanently = 301 // RFC 7231, 6.4.2 StatusFound = 302 // RFC 7231, 6.4.3 StatusSeeOther = 303 // RFC 7231, 6.4.4 StatusNotModified = 304 // RFC 7232, 4.1 StatusUseProxy = 305 // RFC 7231, 6.4.5 StatusTemporaryRedirect = 307 // RFC 7231, 6.4.7 StatusPermanentRedirect = 308 // RFC 7538, 3 StatusBadRequest = 400 // RFC 7231, 6.5.1 StatusUnauthorized = 401 // RFC 7235, 3.1 StatusPaymentRequired = 402 // RFC 7231, 6.5.2 StatusForbidden = 403 // RFC 7231, 6.5.3 StatusNotFound = 404 // RFC 7231, 6.5.4 StatusMethodNotAllowed = 405 // RFC 7231, 6.5.5 StatusNotAcceptable = 406 // RFC 7231, 6.5.6 StatusProxyAuthRequired = 407 // RFC 7235, 3.2 StatusRequestTimeout = 408 // RFC 7231, 6.5.7 StatusConflict = 409 // RFC 7231, 6.5.8 StatusGone = 410 // RFC 7231, 6.5.9 StatusLengthRequired = 411 // RFC 7231, 6.5.10 StatusPreconditionFailed = 412 // RFC 7232, 4.2 StatusRequestEntityTooLarge = 413 // RFC 7231, 6.5.11 StatusRequestURITooLong = 414 // RFC 7231, 6.5.12 StatusUnsupportedMediaType = 415 // RFC 7231, 6.5.13 StatusRequestedRangeNotSatisfiable = 416 // RFC 7233, 4.4 StatusExpectationFailed = 417 // RFC 7231, 6.5.14 StatusTeapot = 418 // RFC 7168, 2.3.3 StatusMisdirectedRequest = 421 // RFC 7540, 9.1.2 StatusUnprocessableEntity = 422 // RFC 4918, 11.2 StatusLocked = 423 // RFC 4918, 11.3 StatusFailedDependency = 424 // RFC 4918, 11.4 StatusTooEarly = 425 // RFC 8470, 5.2. StatusUpgradeRequired = 426 // RFC 7231, 6.5.15 StatusPreconditionRequired = 428 // RFC 6585, 3 StatusTooManyRequests = 429 // RFC 6585, 4 StatusRequestHeaderFieldsTooLarge = 431 // RFC 6585, 5 StatusUnavailableForLegalReasons = 451 // RFC 7725, 3 StatusInternalServerError = 500 // RFC 7231, 6.6.1 StatusNotImplemented = 501 // RFC 7231, 6.6.2 StatusBadGateway = 502 // RFC 7231, 6.6.3 StatusServiceUnavailable = 503 // RFC 7231, 6.6.4 StatusGatewayTimeout = 504 // RFC 7231, 6.6.5 StatusHTTPVersionNotSupported = 505 // RFC 7231, 6.6.6 StatusVariantAlsoNegotiates = 506 // RFC 2295, 8.1 StatusInsufficientStorage = 507 // RFC 4918, 11.5 StatusLoopDetected = 508 // RFC 5842, 7.2 StatusNotExtended = 510 // RFC 2774, 7 StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6 ) Errors var ( ErrBadRequest = NewError(StatusBadRequest) // RFC 7231, 6.5.1 ErrUnauthorized = NewError(StatusUnauthorized) // RFC 7235, 3.1 ErrPaymentRequired = NewError(StatusPaymentRequired) // RFC 7231, 6.5.2 ErrForbidden = NewError(StatusForbidden) // RFC 7231, 6.5.3 ErrNotFound = NewError(StatusNotFound) // RFC 7231, 6.5.4 ErrMethodNotAllowed = NewError(StatusMethodNotAllowed) // RFC 7231, 6.5.5 ErrNotAcceptable = NewError(StatusNotAcceptable) // RFC 7231, 6.5.6 ErrProxyAuthRequired = NewError(StatusProxyAuthRequired) // RFC 7235, 3.2 ErrRequestTimeout = NewError(StatusRequestTimeout) // RFC 7231, 6.5.7 ErrConflict = NewError(StatusConflict) // RFC 7231, 6.5.8 ErrGone = NewError(StatusGone) // RFC 7231, 6.5.9 ErrLengthRequired = NewError(StatusLengthRequired) // RFC 7231, 6.5.10 ErrPreconditionFailed = NewError(StatusPreconditionFailed) // RFC 7232, 4.2 ErrRequestEntityTooLarge = NewError(StatusRequestEntityTooLarge) // RFC 7231, 6.5.11 ErrRequestURITooLong = NewError(StatusRequestURITooLong) // RFC 7231, 6.5.12 ErrUnsupportedMediaType = NewError(StatusUnsupportedMediaType) // RFC 7231, 6.5.13 ErrRequestedRangeNotSatisfiable = NewError(StatusRequestedRangeNotSatisfiable) // RFC 7233, 4.4 ErrExpectationFailed = NewError(StatusExpectationFailed) // RFC 7231, 6.5.14 ErrTeapot = NewError(StatusTeapot) // RFC 7168, 2.3.3 ErrMisdirectedRequest = NewError(StatusMisdirectedRequest) // RFC 7540, 9.1.2 ErrUnprocessableEntity = NewError(StatusUnprocessableEntity) // RFC 4918, 11.2 ErrLocked = NewError(StatusLocked) // RFC 4918, 11.3 ErrFailedDependency = NewError(StatusFailedDependency) // RFC 4918, 11.4 ErrTooEarly = NewError(StatusTooEarly) // RFC 8470, 5.2. ErrUpgradeRequired = NewError(StatusUpgradeRequired) // RFC 7231, 6.5.15 ErrPreconditionRequired = NewError(StatusPreconditionRequired) // RFC 6585, 3 ErrTooManyRequests = NewError(StatusTooManyRequests) // RFC 6585, 4 ErrRequestHeaderFieldsTooLarge = NewError(StatusRequestHeaderFieldsTooLarge) // RFC 6585, 5 ErrUnavailableForLegalReasons = NewError(StatusUnavailableForLegalReasons) // RFC 7725, 3 ErrInternalServerError = NewError(StatusInternalServerError) // RFC 7231, 6.6.1 ErrNotImplemented = NewError(StatusNotImplemented) // RFC 7231, 6.6.2 ErrBadGateway = NewError(StatusBadGateway) // RFC 7231, 6.6.3 ErrServiceUnavailable = NewError(StatusServiceUnavailable) // RFC 7231, 6.6.4 ErrGatewayTimeout = NewError(StatusGatewayTimeout) // RFC 7231, 6.6.5 ErrHTTPVersionNotSupported = NewError(StatusHTTPVersionNotSupported) // RFC 7231, 6.6.6 ErrVariantAlsoNegotiates = NewError(StatusVariantAlsoNegotiates) // RFC 2295, 8.1 ErrInsufficientStorage = NewError(StatusInsufficientStorage) // RFC 4918, 11.5 ErrLoopDetected = NewError(StatusLoopDetected) // RFC 5842, 7.2 ErrNotExtended = NewError(StatusNotExtended) // RFC 2774, 7 ErrNetworkAuthenticationRequired = NewError(StatusNetworkAuthenticationRequired) // RFC 6585, 6 ) HTTP Headers were copied from net/http. const ( HeaderAuthorization = &quot;Authorization&quot; HeaderProxyAuthenticate = &quot;Proxy-Authenticate&quot; HeaderProxyAuthorization = &quot;Proxy-Authorization&quot; HeaderWWWAuthenticate = &quot;WWW-Authenticate&quot; HeaderAge = &quot;Age&quot; HeaderCacheControl = &quot;Cache-Control&quot; HeaderClearSiteData = &quot;Clear-Site-Data&quot; HeaderExpires = &quot;Expires&quot; HeaderPragma = &quot;Pragma&quot; HeaderWarning = &quot;Warning&quot; HeaderAcceptCH = &quot;Accept-CH&quot; HeaderAcceptCHLifetime = &quot;Accept-CH-Lifetime&quot; HeaderContentDPR = &quot;Content-DPR&quot; HeaderDPR = &quot;DPR&quot; HeaderEarlyData = &quot;Early-Data&quot; HeaderSaveData = &quot;Save-Data&quot; HeaderViewportWidth = &quot;Viewport-Width&quot; HeaderWidth = &quot;Width&quot; HeaderETag = &quot;ETag&quot; HeaderIfMatch = &quot;If-Match&quot; HeaderIfModifiedSince = &quot;If-Modified-Since&quot; HeaderIfNoneMatch = &quot;If-None-Match&quot; HeaderIfUnmodifiedSince = &quot;If-Unmodified-Since&quot; HeaderLastModified = &quot;Last-Modified&quot; HeaderVary = &quot;Vary&quot; HeaderConnection = &quot;Connection&quot; HeaderKeepAlive = &quot;Keep-Alive&quot; HeaderAccept = &quot;Accept&quot; HeaderAcceptCharset = &quot;Accept-Charset&quot; HeaderAcceptEncoding = &quot;Accept-Encoding&quot; HeaderAcceptLanguage = &quot;Accept-Language&quot; HeaderCookie = &quot;Cookie&quot; HeaderExpect = &quot;Expect&quot; HeaderMaxForwards = &quot;Max-Forwards&quot; HeaderSetCookie = &quot;Set-Cookie&quot; HeaderAccessControlAllowCredentials = &quot;Access-Control-Allow-Credentials&quot; HeaderAccessControlAllowHeaders = &quot;Access-Control-Allow-Headers&quot; HeaderAccessControlAllowMethods = &quot;Access-Control-Allow-Methods&quot; HeaderAccessControlAllowOrigin = &quot;Access-Control-Allow-Origin&quot; HeaderAccessControlExposeHeaders = &quot;Access-Control-Expose-Headers&quot; HeaderAccessControlMaxAge = &quot;Access-Control-Max-Age&quot; HeaderAccessControlRequestHeaders = &quot;Access-Control-Request-Headers&quot; HeaderAccessControlRequestMethod = &quot;Access-Control-Request-Method&quot; HeaderOrigin = &quot;Origin&quot; HeaderTimingAllowOrigin = &quot;Timing-Allow-Origin&quot; HeaderXPermittedCrossDomainPolicies = &quot;X-Permitted-Cross-Domain-Policies&quot; HeaderDNT = &quot;DNT&quot; HeaderTk = &quot;Tk&quot; HeaderContentDisposition = &quot;Content-Disposition&quot; HeaderContentEncoding = &quot;Content-Encoding&quot; HeaderContentLanguage = &quot;Content-Language&quot; HeaderContentLength = &quot;Content-Length&quot; HeaderContentLocation = &quot;Content-Location&quot; HeaderContentType = &quot;Content-Type&quot; HeaderForwarded = &quot;Forwarded&quot; HeaderVia = &quot;Via&quot; HeaderXForwardedFor = &quot;X-Forwarded-For&quot; HeaderXForwardedHost = &quot;X-Forwarded-Host&quot; HeaderXForwardedProto = &quot;X-Forwarded-Proto&quot; HeaderXForwardedProtocol = &quot;X-Forwarded-Protocol&quot; HeaderXForwardedSsl = &quot;X-Forwarded-Ssl&quot; HeaderXUrlScheme = &quot;X-Url-Scheme&quot; HeaderLocation = &quot;Location&quot; HeaderFrom = &quot;From&quot; HeaderHost = &quot;Host&quot; HeaderReferer = &quot;Referer&quot; HeaderReferrerPolicy = &quot;Referrer-Policy&quot; HeaderUserAgent = &quot;User-Agent&quot; HeaderAllow = &quot;Allow&quot; HeaderServer = &quot;Server&quot; HeaderAcceptRanges = &quot;Accept-Ranges&quot; HeaderContentRange = &quot;Content-Range&quot; HeaderIfRange = &quot;If-Range&quot; HeaderRange = &quot;Range&quot; HeaderContentSecurityPolicy = &quot;Content-Security-Policy&quot; HeaderContentSecurityPolicyReportOnly = &quot;Content-Security-Policy-Report-Only&quot; HeaderCrossOriginResourcePolicy = &quot;Cross-Origin-Resource-Policy&quot; HeaderExpectCT = &quot;Expect-CT&quot; HeaderFeaturePolicy = &quot;Feature-Policy&quot; HeaderPublicKeyPins = &quot;Public-Key-Pins&quot; HeaderPublicKeyPinsReportOnly = &quot;Public-Key-Pins-Report-Only&quot; HeaderStrictTransportSecurity = &quot;Strict-Transport-Security&quot; HeaderUpgradeInsecureRequests = &quot;Upgrade-Insecure-Requests&quot; HeaderXContentTypeOptions = &quot;X-Content-Type-Options&quot; HeaderXDownloadOptions = &quot;X-Download-Options&quot; HeaderXFrameOptions = &quot;X-Frame-Options&quot; HeaderXPoweredBy = &quot;X-Powered-By&quot; HeaderXXSSProtection = &quot;X-XSS-Protection&quot; HeaderLastEventID = &quot;Last-Event-ID&quot; HeaderNEL = &quot;NEL&quot; HeaderPingFrom = &quot;Ping-From&quot; HeaderPingTo = &quot;Ping-To&quot; HeaderReportTo = &quot;Report-To&quot; HeaderTE = &quot;TE&quot; HeaderTrailer = &quot;Trailer&quot; HeaderTransferEncoding = &quot;Transfer-Encoding&quot; HeaderSecWebSocketAccept = &quot;Sec-WebSocket-Accept&quot; HeaderSecWebSocketExtensions = &quot;Sec-WebSocket-Extensions&quot; HeaderSecWebSocketKey = &quot;Sec-WebSocket-Key&quot; HeaderSecWebSocketProtocol = &quot;Sec-WebSocket-Protocol&quot; HeaderSecWebSocketVersion = &quot;Sec-WebSocket-Version&quot; HeaderAcceptPatch = &quot;Accept-Patch&quot; HeaderAcceptPushPolicy = &quot;Accept-Push-Policy&quot; HeaderAcceptSignature = &quot;Accept-Signature&quot; HeaderAltSvc = &quot;Alt-Svc&quot; HeaderDate = &quot;Date&quot; HeaderIndex = &quot;Index&quot; HeaderLargeAllocation = &quot;Large-Allocation&quot; HeaderLink = &quot;Link&quot; HeaderPushPolicy = &quot;Push-Policy&quot; HeaderRetryAfter = &quot;Retry-After&quot; HeaderServerTiming = &quot;Server-Timing&quot; HeaderSignature = &quot;Signature&quot; HeaderSignedHeaders = &quot;Signed-Headers&quot; HeaderSourceMap = &quot;SourceMap&quot; HeaderUpgrade = &quot;Upgrade&quot; HeaderXDNSPrefetchControl = &quot;X-DNS-Prefetch-Control&quot; HeaderXPingback = &quot;X-Pingback&quot; HeaderXRequestID = &quot;X-Request-ID&quot; HeaderXRequestedWith = &quot;X-Requested-With&quot; HeaderXRobotsTag = &quot;X-Robots-Tag&quot; HeaderXUACompatible = &quot;X-UA-Compatible&quot; ) ","keywords":""},{"title":"🌎 Client","type":0,"sectionRef":"#","url":"/api/client","content":"","keywords":""},{"title":"Start request​","type":1,"pageTitle":"🌎 Client","url":"/api/client#start-request","content":"Start a http request with http method and url. Signatures // Client http methods func (c *Client) Get(url string) *Agent func (c *Client) Head(url string) *Agent func (c *Client) Post(url string) *Agent func (c *Client) Put(url string) *Agent func (c *Client) Patch(url string) *Agent func (c *Client) Delete(url string) *Agent  "},{"title":"✨ Agent​","type":1,"pageTitle":"🌎 Client","url":"/api/client#-agent","content":"Agent is built on top of FastHTTP's HostClient which has lots of convenient helper methods such as dedicated methods for request methods. "},{"title":"Parse​","type":1,"pageTitle":"🌎 Client","url":"/api/client#parse","content":"Parse initializes a HostClient. Parse a := AcquireAgent() req := a.Request() req.Header.SetMethod(MethodGet) req.SetRequestURI(&quot;http://example.com&quot;) if err := a.Parse(); err != nil { panic(err) } code, body, errs := a.Bytes() // ...  "},{"title":"Set​","type":1,"pageTitle":"🌎 Client","url":"/api/client#set","content":"Set sets the given key: value header. Signature func (a *Agent) Set(k, v string) *Agent func (a *Agent) SetBytesK(k []byte, v string) *Agent func (a *Agent) SetBytesV(k string, v []byte) *Agent func (a *Agent) SetBytesKV(k []byte, v []byte) *Agent  Example agent.Set(&quot;k1&quot;, &quot;v1&quot;). SetBytesK([]byte(&quot;k1&quot;), &quot;v1&quot;). SetBytesV(&quot;k1&quot;, []byte(&quot;v1&quot;)). SetBytesKV([]byte(&quot;k2&quot;), []byte(&quot;v2&quot;)) // ...  "},{"title":"Add​","type":1,"pageTitle":"🌎 Client","url":"/api/client#add","content":"Add adds the given key: value header. Multiple headers with the same key may be added with this function. Signature func (a *Agent) Add(k, v string) *Agent func (a *Agent) AddBytesK(k []byte, v string) *Agent func (a *Agent) AddBytesV(k string, v []byte) *Agent func (a *Agent) AddBytesKV(k []byte, v []byte) *Agent  Example agent.Add(&quot;k1&quot;, &quot;v1&quot;). AddBytesK([]byte(&quot;k1&quot;), &quot;v1&quot;). AddBytesV(&quot;k1&quot;, []byte(&quot;v1&quot;)). AddBytesKV([]byte(&quot;k2&quot;), []byte(&quot;v2&quot;)) // Headers: // K1: v1 // K1: v1 // K1: v1 // K2: v2  "},{"title":"ConnectionClose​","type":1,"pageTitle":"🌎 Client","url":"/api/client#connectionclose","content":"ConnectionClose adds the Connection: close header. Signature func (a *Agent) ConnectionClose() *Agent  Example agent.ConnectionClose() // ...  "},{"title":"UserAgent​","type":1,"pageTitle":"🌎 Client","url":"/api/client#useragent","content":"UserAgent sets User-Agent header value. Signature func (a *Agent) UserAgent(userAgent string) *Agent func (a *Agent) UserAgentBytes(userAgent []byte) *Agent  Example agent.UserAgent(&quot;fiber&quot;) // ...  "},{"title":"Cookie​","type":1,"pageTitle":"🌎 Client","url":"/api/client#cookie","content":"Cookie sets a cookie in key: value form. Cookies can be used to set multiple cookies. Signature func (a *Agent) Cookie(key, value string) *Agent func (a *Agent) CookieBytesK(key []byte, value string) *Agent func (a *Agent) CookieBytesKV(key, value []byte) *Agent func (a *Agent) Cookies(kv ...string) *Agent func (a *Agent) CookiesBytesKV(kv ...[]byte) *Agent  Example agent.Cookie(&quot;k&quot;, &quot;v&quot;) agent.Cookies(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;) // ...  "},{"title":"Referer​","type":1,"pageTitle":"🌎 Client","url":"/api/client#referer","content":"Referer sets the Referer header value. Signature func (a *Agent) Referer(referer string) *Agent func (a *Agent) RefererBytes(referer []byte) *Agent  Example agent.Referer(&quot;https://docs.gofiber.io&quot;) // ...  "},{"title":"ContentType​","type":1,"pageTitle":"🌎 Client","url":"/api/client#contenttype","content":"ContentType sets Content-Type header value. Signature func (a *Agent) ContentType(contentType string) *Agent func (a *Agent) ContentTypeBytes(contentType []byte) *Agent  Example agent.ContentType(&quot;custom-type&quot;) // ...  "},{"title":"Host​","type":1,"pageTitle":"🌎 Client","url":"/api/client#host","content":"Host sets the Host header. Signature func (a *Agent) Host(host string) *Agent func (a *Agent) HostBytes(host []byte) *Agent  Example agent.Host(&quot;example.com&quot;) // ...  "},{"title":"QueryString​","type":1,"pageTitle":"🌎 Client","url":"/api/client#querystring","content":"QueryString sets the URI query string. Signature func (a *Agent) QueryString(queryString string) *Agent func (a *Agent) QueryStringBytes(queryString []byte) *Agent  Example agent.QueryString(&quot;foo=bar&quot;) // ...  "},{"title":"BasicAuth​","type":1,"pageTitle":"🌎 Client","url":"/api/client#basicauth","content":"BasicAuth sets the URI username and password using HTTP Basic Auth. Signature func (a *Agent) BasicAuth(username, password string) *Agent func (a *Agent) BasicAuthBytes(username, password []byte) *Agent  Example agent.BasicAuth(&quot;foo&quot;, &quot;bar&quot;) // ...  "},{"title":"Body​","type":1,"pageTitle":"🌎 Client","url":"/api/client#body","content":"There are several ways to set request body. Signature func (a *Agent) BodyString(bodyString string) *Agent func (a *Agent) Body(body []byte) *Agent // BodyStream sets request body stream and, optionally body size. // // If bodySize is &gt;= 0, then the bodyStream must provide exactly bodySize bytes // before returning io.EOF. // // If bodySize &lt; 0, then bodyStream is read until io.EOF. // // bodyStream.Close() is called after finishing reading all body data // if it implements io.Closer. // // Note that GET and HEAD requests cannot have body. func (a *Agent) BodyStream(bodyStream io.Reader, bodySize int) *Agent  Example agent.BodyString(&quot;foo=bar&quot;) agent.Body([]byte(&quot;bar=baz&quot;)) agent.BodyStream(strings.NewReader(&quot;body=stream&quot;), -1) // ...  "},{"title":"JSON​","type":1,"pageTitle":"🌎 Client","url":"/api/client#json","content":"JSON sends a JSON request by setting the Content-Type header to application/json. Signature func (a *Agent) JSON(v interface{}) *Agent  Example agent.JSON(fiber.Map{&quot;success&quot;: true}) // ...  "},{"title":"XML​","type":1,"pageTitle":"🌎 Client","url":"/api/client#xml","content":"XML sends an XML request by setting the Content-Type header to application/xml. Signature func (a *Agent) XML(v interface{}) *Agent  Example agent.XML(fiber.Map{&quot;success&quot;: true}) // ...  "},{"title":"Form​","type":1,"pageTitle":"🌎 Client","url":"/api/client#form","content":"Form sends a form request by setting the Content-Type header to application/x-www-form-urlencoded. Signature // Form sends form request with body if args is non-nil. // // It is recommended obtaining args via AcquireArgs and release it // manually in performance-critical code. func (a *Agent) Form(args *Args) *Agent  Example args := AcquireArgs() args.Set(&quot;foo&quot;, &quot;bar&quot;) agent.Form(args) // ... ReleaseArgs(args)  "},{"title":"MultipartForm​","type":1,"pageTitle":"🌎 Client","url":"/api/client#multipartform","content":"MultipartForm sends multipart form request by setting the Content-Type header to multipart/form-data. These requests can include key-value's and files. Signature // MultipartForm sends multipart form request with k-v and files. // // It is recommended to obtain args via AcquireArgs and release it // manually in performance-critical code. func (a *Agent) MultipartForm(args *Args) *Agent  Example args := AcquireArgs() args.Set(&quot;foo&quot;, &quot;bar&quot;) agent.MultipartForm(args) // ... ReleaseArgs(args)  Fiber provides several methods for sending files. Note that they must be called before MultipartForm. Boundary​ Boundary sets boundary for multipart form request. Signature func (a *Agent) Boundary(boundary string) *Agent  Example agent.Boundary(&quot;myBoundary&quot;) .MultipartForm(nil) // ...  SendFile(s)​ SendFile read a file and appends it to a multipart form request. Sendfiles can be used to append multiple files. Signature func (a *Agent) SendFile(filename string, fieldname ...string) *Agent func (a *Agent) SendFiles(filenamesAndFieldnames ...string) *Agent  Example agent.SendFile(&quot;f&quot;, &quot;field name&quot;) .SendFiles(&quot;f1&quot;, &quot;field name1&quot;, &quot;f2&quot;). .MultipartForm(nil) // ...  FileData​ FileData appends file data for multipart form request. // FormFile represents multipart form file type FormFile struct { // Fieldname is form file's field name Fieldname string // Name is form file's name Name string // Content is form file's content Content []byte }  Signature // FileData appends files for multipart form request. // // It is recommended obtaining formFile via AcquireFormFile and release it // manually in performance-critical code. func (a *Agent) FileData(formFiles ...*FormFile) *Agent  Example ff1 := &amp;FormFile{&quot;filename1&quot;, &quot;field name1&quot;, []byte(&quot;content&quot;)} ff2 := &amp;FormFile{&quot;filename2&quot;, &quot;field name2&quot;, []byte(&quot;content&quot;)} agent.FileData(ff1, ff2). MultipartForm(nil) // ...  "},{"title":"Debug​","type":1,"pageTitle":"🌎 Client","url":"/api/client#debug","content":"Debug mode enables logging request and response detail to io.writer(default is os.Stdout). Signature func (a *Agent) Debug(w ...io.Writer) *Agent  Example agent.Debug() // ...  "},{"title":"Timeout​","type":1,"pageTitle":"🌎 Client","url":"/api/client#timeout","content":"Timeout sets request timeout duration. Signature func (a *Agent) Timeout(timeout time.Duration) *Agent  Example agent.Timeout(time.Second) // ...  "},{"title":"Reuse​","type":1,"pageTitle":"🌎 Client","url":"/api/client#reuse","content":"Reuse enables the Agent instance to be used again after one request. If agent is reusable, then it should be released manually when it is no longer used. Signature func (a *Agent) Reuse() *Agent  Example agent.Reuse() // ...  "},{"title":"InsecureSkipVerify​","type":1,"pageTitle":"🌎 Client","url":"/api/client#insecureskipverify","content":"InsecureSkipVerify controls whether the Agent verifies the server certificate chain and host name. Signature func (a *Agent) InsecureSkipVerify() *Agent  Example agent.InsecureSkipVerify() // ...  "},{"title":"TLSConfig​","type":1,"pageTitle":"🌎 Client","url":"/api/client#tlsconfig","content":"TLSConfig sets tls config. Signature func (a *Agent) TLSConfig(config *tls.Config) *Agent  Example // Create tls certificate cer, _ := tls.LoadX509KeyPair(&quot;pem&quot;, &quot;key&quot;) config := &amp;tls.Config{ Certificates: []tls.Certificate{cer}, } agent.TLSConfig(config) // ...  "},{"title":"MaxRedirectsCount​","type":1,"pageTitle":"🌎 Client","url":"/api/client#maxredirectscount","content":"MaxRedirectsCount sets max redirect count for GET and HEAD. Signature func (a *Agent) MaxRedirectsCount(count int) *Agent  Example agent.MaxRedirectsCount(7) // ...  "},{"title":"JSONEncoder​","type":1,"pageTitle":"🌎 Client","url":"/api/client#jsonencoder","content":"JSONEncoder sets custom json encoder. Signature func (a *Agent) JSONEncoder(jsonEncoder utils.JSONMarshal) *Agent  Example agent.JSONEncoder(json.Marshal) // ...  "},{"title":"JSONDecoder​","type":1,"pageTitle":"🌎 Client","url":"/api/client#jsondecoder","content":"JSONDecoder sets custom json decoder. Signature func (a *Agent) JSONDecoder(jsonDecoder utils.JSONUnmarshal) *Agent  Example agent.JSONDecoder(json.Unmarshal) // ...  "},{"title":"Request​","type":1,"pageTitle":"🌎 Client","url":"/api/client#request","content":"Request returns Agent request instance. Signature func (a *Agent) Request() *Request  Example req := agent.Request() // ...  "},{"title":"SetResponse​","type":1,"pageTitle":"🌎 Client","url":"/api/client#setresponse","content":"SetResponse sets custom response for the Agent instance. It is recommended obtaining custom response via AcquireResponse and release it manually in performance-critical code. Signature func (a *Agent) SetResponse(customResp *Response) *Agent  Example resp := AcquireResponse() agent.SetResponse(resp) // ... ReleaseResponse(resp)  "},{"title":"Dest​","type":1,"pageTitle":"🌎 Client","url":"/api/client#dest","content":"Dest sets custom dest. The contents of dest will be replaced by the response body, if the dest is too small a new slice will be allocated. Signature func (a *Agent) Dest(dest []byte) *Agent {  Example agent.Dest(nil) // ...  "},{"title":"Bytes​","type":1,"pageTitle":"🌎 Client","url":"/api/client#bytes","content":"Bytes returns the status code, bytes body and errors of url. Signature func (a *Agent) Bytes() (code int, body []byte, errs []error)  Example code, body, errs := agent.Bytes() // ...  "},{"title":"String​","type":1,"pageTitle":"🌎 Client","url":"/api/client#string","content":"String returns the status code, string body and errors of url. Signature func (a *Agent) String() (int, string, []error)  Example code, body, errs := agent.String() // ...  "},{"title":"Struct​","type":1,"pageTitle":"🌎 Client","url":"/api/client#struct","content":"Struct returns the status code, bytes body and errors of url. And bytes body will be unmarshalled to given v. Signature func (a *Agent) Struct(v interface{}) (code int, body []byte, errs []error)  Example var d data code, body, errs := agent.Struct(&amp;d) // ...  "},{"title":"RetryIf​","type":1,"pageTitle":"🌎 Client","url":"/api/client#retryif","content":"RetryIf controls whether a retry should be attempted after an error. By default, will use isIdempotent function from fasthttp Signature func (a *Agent) RetryIf(retryIf RetryIfFunc) *Agent  Example agent.Get(&quot;https://example.com&quot;).RetryIf(func (req *fiber.Request) bool { return req.URI() == &quot;https://example.com&quot; }) // ...  "},{"title":"📦 Fiber","type":0,"sectionRef":"#","url":"/api/fiber","content":"","keywords":""},{"title":"New​","type":1,"pageTitle":"📦 Fiber","url":"/api/fiber#new","content":"This method creates a new App named instance. You can pass optional config when creating a new instance. Signature func New(config ...Config) *App  Example // Default config app := fiber.New() // ...  "},{"title":"Config​","type":1,"pageTitle":"📦 Fiber","url":"/api/fiber#config","content":"You can pass an optional Config when creating a new Fiber instance. Example // Custom config app := fiber.New(fiber.Config{ Prefork: true, CaseSensitive: true, StrictRouting: true, ServerHeader: &quot;Fiber&quot;, AppName: &quot;Test App v1.0.1&quot; }) // ...  Config fields Property\tType\tDescription\tDefaultAppName\tstring\tThis allows to setup app name for the app\t&quot;&quot; BodyLimit\tint\tSets the maximum allowed size for a request body, if the size exceeds the configured limit, it sends 413 - Request Entity Too Large response.\t4 * 1024 * 1024 CaseSensitive\tbool\tWhen enabled, /Foo and /foo are different routes. When disabled, /Fooand /foo are treated the same.\tfalse ColorScheme\tColors\tYou can define custom color scheme. They'll be used for startup message, route list and some middlewares.\tDefaultColors CompressedFileSuffix\tstring\tAdds a suffix to the original file name and tries saving the resulting compressed file under the new file name.\t&quot;.fiber.gz&quot; Concurrency\tint\tMaximum number of concurrent connections.\t256 * 1024 DisableDefaultContentType\tbool\tWhen set to true, causes the default Content-Type header to be excluded from the Response.\tfalse DisableDefaultDate\tbool\tWhen set to true causes the default date header to be excluded from the response.\tfalse DisableHeaderNormalizing\tbool\tBy default all header names are normalized: conteNT-tYPE -&gt; Content-Type\tfalse DisableKeepalive\tbool\tDisable keep-alive connections, the server will close incoming connections after sending the first response to the client\tfalse DisablePreParseMultipartForm\tbool\tWill not pre parse Multipart Form data if set to true. This option is useful for servers that desire to treat multipart form data as a binary blob, or choose when to parse the data.\tfalse DisableStartupMessage\tbool\tWhen set to true, it will not print out debug information\tfalse ETag\tbool\tEnable or disable ETag header generation, since both weak and strong etags are generated using the same hashing method (CRC-32). Weak ETags are the default when enabled.\tfalse EnableIPValidation\tbool\tIf set to true, c.IP() and c.IPs() will validate IP addresses before returning them. Also, c.IP() will return only the first valid IP rather than just the raw header value that may be a comma seperated string. WARNING: There is a small performance cost to doing this validation. Keep disabled if speed is your only concern and your application is behind a trusted proxy that already validates this header.\tfalse EnablePrintRoutes\tbool\tEnablePrintRoutes enables print all routes with their method, path, name and handler..\tfalse EnableTrustedProxyCheck\tbool\tWhen set to true, fiber will check whether proxy is trusted, using TrustedProxies list. By default c.Protocol() will get value from X-Forwarded-Proto, X-Forwarded-Protocol, X-Forwarded-Ssl or X-Url-Scheme header, c.IP() will get value from ProxyHeader header, c.Hostname() will get value from X-Forwarded-Host header. If EnableTrustedProxyCheck is true, and RemoteIP is in the list of TrustedProxies c.Protocol(), c.IP(), and c.Hostname() will have the same behaviour when EnableTrustedProxyCheck disabled, if RemoteIP isn't in the list, c.Protocol() will return https in case when tls connection is handled by the app, or http otherwise, c.IP() will return RemoteIP() from fasthttp context, c.Hostname() will return fasthttp.Request.URI().Host()\tfalse ErrorHandler\tErrorHandler\tErrorHandler is executed when an error is returned from fiber.Handler. Mounted fiber error handlers are retained by the top-level app and applied on prefix associated requests.\tDefaultErrorHandler GETOnly\tbool\tRejects all non-GET requests if set to true. This option is useful as anti-DoS protection for servers accepting only GET requests. The request size is limited by ReadBufferSize if GETOnly is set.\tfalse IdleTimeout\ttime.Duration\tThe maximum amount of time to wait for the next request when keep-alive is enabled. If IdleTimeout is zero, the value of ReadTimeout is used.\tnil Immutable\tbool\tWhen enabled, all values returned by context methods are immutable. By default, they are valid until you return from the handler; see issue #185.\tfalse JSONDecoder\tutils.JSONUnmarshal\tAllowing for flexibility in using another json library for decoding.\tjson.Unmarshal JSONEncoder\tutils.JSONMarshal\tAllowing for flexibility in using another json library for encoding.\tjson.Marshal Network\tstring\tKnown networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only) WARNING: When prefork is set to true, only &quot;tcp4&quot; and &quot;tcp6&quot; can be chosen.\tNetworkTCP4 PassLocalsToViews\tbool\tPassLocalsToViews Enables passing of the locals set on a fiber.Ctx to the template engine. See our Template Middleware for supported engines.\tfalse Prefork\tbool\tEnables use of theSO_REUSEPORTsocket option. This will spawn multiple Go processes listening on the same port. learn more about socket sharding. NOTE: if enabled, the application will need to be ran through a shell because prefork mode sets environment variables. If you're using Docker, make sure the app is ran with CMD ./app or CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;/app&quot;]. For more info, see this issue comment.\tfalse ProxyHeader\tstring\tThis will enable c.IP() to return the value of the given header key. By default c.IP()will return the Remote IP from the TCP connection, this property can be useful if you are behind a load balancer e.g. X-Forwarded-*.\t&quot;&quot; ReadBufferSize\tint\tper-connection buffer size for requests' reading. This also limits the maximum header size. Increase this buffer if your clients send multi-KB RequestURIs and/or multi-KB headers (for example, BIG cookies).\t4096 ReadTimeout\ttime.Duration\tThe amount of time allowed to read the full request, including the body. The default timeout is unlimited.\tnil ServerHeader\tstring\tEnables the Server HTTP header with the given value.\t&quot;&quot; StreamRequestBody\tbool\tStreamRequestBody enables request body streaming, and calls the handler sooner when given body is larger then the current limit.\tfalse StrictRouting\tbool\tWhen enabled, the router treats /foo and /foo/ as different. Otherwise, the router treats /foo and /foo/ as the same.\tfalse TrustedProxies\t[]string\tContains the list op trusted proxy IP's. Look at EnableTrustedProxyCheck doc. It can take IP or IP range addresses. If it gets IP range, it iterates all possible addresses.\t[]string*__* UnescapePath\tbool\tConverts all encoded characters in the route back before setting the path for the context, so that the routing can also work with URL encoded special characters\tfalse Views\tViews\tViews is the interface that wraps the Render function. See our Template Middleware for supported engines.\tnil ViewsLayout\tstring\tViews Layout is the global layout for all template render until override on Render function. See our Template Middleware for supported engines.\t&quot;&quot; WriteBufferSize\tint\tPer-connection buffer size for responses' writing.\t4096 WriteTimeout\ttime.Duration\tThe maximum duration before timing out writes of the response. The default timeout is unlimited.\tnil XMLEncoder\tutils.XMLMarshal\tAllowing for flexibility in using another XML library for encoding.\txml.Marshal "},{"title":"NewError​","type":1,"pageTitle":"📦 Fiber","url":"/api/fiber#newerror","content":"NewError creates a new HTTPError instance with an optional message. Signature func NewError(code int, message ...string) *Error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return fiber.NewError(782, &quot;Custom error message&quot;) })  "},{"title":"IsChild​","type":1,"pageTitle":"📦 Fiber","url":"/api/fiber#ischild","content":"IsChild determines if the current process is a result of Prefork. Signature func IsChild() bool  Example // Prefork will spawn child processes app := fiber.New(fiber.Config{ Prefork: true, }) if !fiber.IsChild() { fmt.Println(&quot;I'm the parent process&quot;) } else { fmt.Println(&quot;I'm a child process&quot;) } // ...  "},{"title":"BasicAuth","type":0,"sectionRef":"#","url":"/api/middleware/basicauth","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"BasicAuth","url":"/api/middleware/basicauth#signatures","content":"func New(config Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"BasicAuth","url":"/api/middleware/basicauth#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/basicauth&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Provide a minimal config app.Use(basicauth.New(basicauth.Config{ Users: map[string]string{ &quot;john&quot;: &quot;doe&quot;, &quot;admin&quot;: &quot;123456&quot;, }, })) // Or extend your config for customization app.Use(basicauth.New(basicauth.Config{ Users: map[string]string{ &quot;john&quot;: &quot;doe&quot;, &quot;admin&quot;: &quot;123456&quot;, }, Realm: &quot;Forbidden&quot;, Authorizer: func(user, pass string) bool { if user == &quot;john&quot; &amp;&amp; pass == &quot;doe&quot; { return true } if user == &quot;admin&quot; &amp;&amp; pass == &quot;123456&quot; { return true } return false }, Unauthorized: func(c *fiber.Ctx) error { return c.SendFile(&quot;./unauthorized.html&quot;) }, ContextUsername: &quot;_user&quot;, ContextPassword: &quot;_pass&quot;, }))  "},{"title":"Config​","type":1,"pageTitle":"BasicAuth","url":"/api/middleware/basicauth#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Users defines the allowed credentials // // Required. Default: map[string]string{} Users map[string]string // Realm is a string to define realm attribute of BasicAuth. // the realm identifies the system to authenticate against // and can be used by clients to save credentials // // Optional. Default: &quot;Restricted&quot;. Realm string // Authorizer defines a function you can pass // to check the credentials however you want. // It will be called with a username and password // and is expected to return true or false to indicate // that the credentials were approved or not. // // Optional. Default: nil. Authorizer func(string, string) bool // Unauthorized defines the response body for unauthorized responses. // By default it will return with a 401 Unauthorized and the correct WWW-Auth header // // Optional. Default: nil Unauthorized fiber.Handler // ContextUser is the key to store the username in Locals // // Optional. Default: &quot;username&quot; ContextUsername string // ContextPass is the key to store the password in Locals // // Optional. Default: &quot;password&quot; ContextPassword string }  "},{"title":"Default Config​","type":1,"pageTitle":"BasicAuth","url":"/api/middleware/basicauth#default-config","content":"var ConfigDefault = Config{ Next: nil, Users: map[string]string{}, Realm: &quot;Restricted&quot;, Authorizer: nil, Unauthorized: nil, ContextUsername: &quot;username&quot;, ContextPassword: &quot;password&quot;, }  "},{"title":"Cache","type":0,"sectionRef":"#","url":"/api/middleware/cache","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Cache","url":"/api/middleware/cache#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Cache","url":"/api/middleware/cache#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/cache&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Initialize default config app.Use(cache.New()) // Or extend your config for customization app.Use(cache.New(cache.Config{ Next: func(c *fiber.Ctx) bool { return c.Query(&quot;refresh&quot;) == &quot;true&quot; }, Expiration: 30 * time.Minute, CacheControl: true, }))  Or you can custom key and expire time like this: app.Use(New(Config{ ExpirationGenerator: func(c *fiber.Ctx, cfg *Config) time.Duration { newCacheTime, _ := strconv.Atoi(c.GetRespHeader(&quot;Cache-Time&quot;, &quot;600&quot;)) return time.Second * time.Duration(newCacheTime) }, KeyGenerator: func(c *fiber.Ctx) string { return c.Path() } })) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Response().Header.Add(&quot;Cache-Time&quot;, &quot;6000&quot;) return c.SendString(&quot;hi&quot;) })  "},{"title":"Config​","type":1,"pageTitle":"Cache","url":"/api/middleware/cache#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Expiration is the time that an cached response will live // // Optional. Default: 1 * time.Minute Expiration time.Duration // CacheControl enables client side caching if set to true // // Optional. Default: false CacheControl bool // Key allows you to generate custom keys, by default c.Path() is used // // Default: func(c *fiber.Ctx) string { // return utils.CopyString(c.Path()) // } KeyGenerator func(*fiber.Ctx) string // allows you to generate custom Expiration Key By Key, default is Expiration (Optional) // // Default: nil ExpirationGenerator func(*fiber.Ctx, *Config) time.Duration // Store is used to store the state of the middleware // // Default: an in memory store for this process only Storage fiber.Storage // allows you to store additional headers generated by next middlewares &amp; handler // // Default: false StoreResponseHeaders bool // Max number of bytes of response bodies simultaneously stored in cache. When limit is reached, // entries with the nearest expiration are deleted to make room for new. // 0 means no limit // // Default: 0 MaxBytes uint // You can specify HTTP methods to cache. // The middleware just caches the routes of its methods in this slice. // // Default: []string{fiber.MethodGet, fiber.MethodHead} Methods []string }  "},{"title":"Default Config​","type":1,"pageTitle":"Cache","url":"/api/middleware/cache#default-config","content":"// ConfigDefault is the default config var ConfigDefault = Config{ Next: nil, Expiration: 1 * time.Minute, CacheControl: false, KeyGenerator: func(c *fiber.Ctx) string { return utils.CopyString(c.Path()) }, ExpirationGenerator: nil, StoreResponseHeaders: false, Storage: nil, MaxBytes: 0, Methods: []string{fiber.MethodGet, fiber.MethodHead}, }  "},{"title":"Compress","type":0,"sectionRef":"#","url":"/api/middleware/compress","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Compress","url":"/api/middleware/compress#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Compress","url":"/api/middleware/compress#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/compress&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware config app.Use(compress.New()) // Provide a custom compression level app.Use(compress.New(compress.Config{ Level: compress.LevelBestSpeed, // 1 })) // Skip middleware for specific routes app.Use(compress.New(compress.Config{ Next: func(c *fiber.Ctx) bool { return c.Path() == &quot;/dont_compress&quot; }, Level: compress.LevelBestSpeed, // 1 }))  "},{"title":"Config​","type":1,"pageTitle":"Compress","url":"/api/middleware/compress#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // CompressLevel determines the compression algoritm // // Optional. Default: LevelDefault // LevelDisabled: -1 // LevelDefault: 0 // LevelBestSpeed: 1 // LevelBestCompression: 2 Level int }  "},{"title":"Default Config​","type":1,"pageTitle":"Compress","url":"/api/middleware/compress#default-config","content":"var ConfigDefault = Config{ Next: nil, Level: LevelDefault, }  "},{"title":"Constants​","type":1,"pageTitle":"Compress","url":"/api/middleware/compress#constants","content":"// Compression levels const ( LevelDisabled = -1 LevelDefault = 0 LevelBestSpeed = 1 LevelBestCompression = 2 )  "},{"title":"CORS","type":0,"sectionRef":"#","url":"/api/middleware/cors","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"CORS","url":"/api/middleware/cors#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"CORS","url":"/api/middleware/cors#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/cors&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default config app.Use(cors.New()) // Or extend your config for customization app.Use(cors.New(cors.Config{ AllowOrigins: &quot;https://gofiber.io, https://gofiber.net&quot;, AllowHeaders: &quot;Origin, Content-Type, Accept&quot;, }))  "},{"title":"Config​","type":1,"pageTitle":"CORS","url":"/api/middleware/cors#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // AllowOrigin defines a list of origins that may access the resource. // // Optional. Default value &quot;*&quot; AllowOrigins string // AllowMethods defines a list of methods allowed when accessing the resource. // This is used in response to a preflight request. // // Optional. Default value &quot;GET,POST,HEAD,PUT,DELETE,PATCH&quot; AllowMethods string // AllowHeaders defines a list of request headers that can be used when // making the actual request. This is in response to a preflight request. // // Optional. Default value &quot;&quot;. AllowHeaders string // AllowCredentials indicates whether or not the response to the request // can be exposed when the credentials flag is true. When used as part of // a response to a preflight request, this indicates whether or not the // actual request can be made using credentials. // // Optional. Default value false. AllowCredentials bool // ExposeHeaders defines a whitelist headers that clients are allowed to // access. // // Optional. Default value &quot;&quot;. ExposeHeaders string // MaxAge indicates how long (in seconds) the results of a preflight request // can be cached. // // Optional. Default value 0. MaxAge int }  "},{"title":"Default Config​","type":1,"pageTitle":"CORS","url":"/api/middleware/cors#default-config","content":"var ConfigDefault = Config{ Next: nil, AllowOrigins: &quot;*&quot;, AllowMethods: &quot;GET,POST,HEAD,PUT,DELETE,PATCH&quot;, AllowHeaders: &quot;&quot;, AllowCredentials: false, ExposeHeaders: &quot;&quot;, MaxAge: 0, }  "},{"title":"CSRF","type":0,"sectionRef":"#","url":"/api/middleware/csrf","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"CSRF","url":"/api/middleware/csrf#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"CSRF","url":"/api/middleware/csrf#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/csrf&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Initialize default config app.Use(csrf.New()) // Or extend your config for customization app.Use(csrf.New(csrf.Config{ KeyLookup: &quot;header:X-Csrf-Token&quot;, CookieName: &quot;csrf_&quot;, CookieSameSite: &quot;Strict&quot;, Expiration: 1 * time.Hour, KeyGenerator: utils.UUID, Extractor: func(c *fiber.Ctx) (string, error) { ... }, }))  Note: KeyLookup will be ignored if Extractor is explicitly set. "},{"title":"Config​","type":1,"pageTitle":"CSRF","url":"/api/middleware/csrf#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // KeyLookup is a string in the form of &quot;&lt;source&gt;:&lt;key&gt;&quot; that is used // to create an Extractor that extracts the token from the request. // Possible values: // - &quot;header:&lt;name&gt;&quot; // - &quot;query:&lt;name&gt;&quot; // - &quot;param:&lt;name&gt;&quot; // - &quot;form:&lt;name&gt;&quot; // - &quot;cookie:&lt;name&gt;&quot; // // Ignored if an Extractor is explicitly set. // // Optional. Default: &quot;header:X-CSRF-Token&quot; KeyLookup string // Name of the session cookie. This cookie will store session key. // Optional. Default value &quot;_csrf&quot;. CookieName string // Domain of the CSRF cookie. // Optional. Default value &quot;&quot;. CookieDomain string // Path of the CSRF cookie. // Optional. Default value &quot;&quot;. CookiePath string // Indicates if CSRF cookie is secure. // Optional. Default value false. CookieSecure bool // Indicates if CSRF cookie is HTTP only. // Optional. Default value false. CookieHTTPOnly bool // Indicates if CSRF cookie is requested by SameSite. // Optional. Default value &quot;Lax&quot;. CookieSameSite string // Decides whether cookie should last for only the browser sesison. // Ignores Expiration if set to true CookieSessionOnly bool // Expiration is the duration before csrf token will expire // // Optional. Default: 1 * time.Hour Expiration time.Duration // Store is used to store the state of the middleware // // Optional. Default: memory.New() Storage fiber.Storage // Context key to store generated CSRF token into context. // If left empty, token will not be stored in context. // // Optional. Default: &quot;&quot; ContextKey string // KeyGenerator creates a new CSRF token // // Optional. Default: utils.UUID KeyGenerator func() string // Extractor returns the csrf token // // If set this will be used in place of an Extractor based on KeyLookup. // // Optional. Default will create an Extractor based on KeyLookup. Extractor func(c *fiber.Ctx) (string, error) }  "},{"title":"Default Config​","type":1,"pageTitle":"CSRF","url":"/api/middleware/csrf#default-config","content":"var ConfigDefault = Config{ KeyLookup: &quot;header:X-Csrf-Token&quot;, CookieName: &quot;csrf_&quot;, CookieSameSite: &quot;Lax&quot;, Expiration: 1 * time.Hour, KeyGenerator: utils.UUID, }  "},{"title":"Encrypt Cookie","type":0,"sectionRef":"#","url":"/api/middleware/encryptcookie","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Encrypt Cookie","url":"/api/middleware/encryptcookie#signatures","content":"// Intitializes the middleware func New(config ...Config) fiber.Handler // Returns a random 32 character long string func GenerateKey() string  "},{"title":"Examples​","type":1,"pageTitle":"Encrypt Cookie","url":"/api/middleware/encryptcookie#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/encryptcookie&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware config app.Use(encryptcookie.New(encryptcookie.Config{ Key: &quot;secret-thirty-2-character-string&quot;, })) // Get / reading out the encrypted cookie app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;value=&quot; + c.Cookies(&quot;test&quot;)) }) // Post / create the encrypted cookie app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { c.Cookie(&amp;fiber.Cookie{ Name: &quot;test&quot;, Value: &quot;SomeThing&quot;, }) return nil })  "},{"title":"Config​","type":1,"pageTitle":"Encrypt Cookie","url":"/api/middleware/encryptcookie#config","content":"type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Array of cookie keys that should not be encrypted. // // Optional. Default: [&quot;csrf_&quot;] Except []string // Base64 encoded unique key to encode &amp; decode cookies. // // Required. Key length should be 32 characters. // You may use `encryptcookie.GenerateKey()` to generate a new key. Key string // Custom function to encrypt cookies. // // Optional. Default: EncryptCookie Encryptor func(decryptedString, key string) (string, error) // Custom function to decrypt cookies. // // Optional. Default: DecryptCookie Decryptor func(encryptedString, key string) (string, error) }  "},{"title":"Default Config​","type":1,"pageTitle":"Encrypt Cookie","url":"/api/middleware/encryptcookie#default-config","content":"// `Key` must be a 32 character string. It's used to encrpyt the values, so make sure it is random and keep it secret. // You can call `encryptcookie.GenerateKey()` to create a random key for you. // Make sure not to set `Key` to `encryptcookie.GenerateKey()` because that will create a new key every run. app.Use(encryptcookie.New(encryptcookie.Config{ Key: &quot;secret-thirty-2-character-string&quot;, }))  "},{"title":"Usage of CSRF and Encryptcookie Middlewares with Custom Cookie Names​","type":1,"pageTitle":"Encrypt Cookie","url":"/api/middleware/encryptcookie#usage-of-csrf-and-encryptcookie-middlewares-with-custom-cookie-names","content":"Normally, encryptcookie middleware skips csrf_ cookies. However, it won't work when you use custom cookie names for CSRF. You should update Except config to avoid this problem. For example: app.Use(encryptcookie.New(encryptcookie.Config{ Key: &quot;secret-thirty-2-character-string&quot;, Except: []string{&quot;csrf_1&quot;}, // exclude CSRF cookie })) app.Use(csrf.New(csrf.Config{ KeyLookup: &quot;form:test&quot;, CookieName: &quot;csrf_1&quot;, CookieHTTPOnly: true, }))  "},{"title":"EnvVar","type":0,"sectionRef":"#","url":"/api/middleware/envvar","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#examples","content":"First import the middleware from Fiber, import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/envvar&quot; )  Then create a Fiber app with app := fiber.New(). Note: You need to provide a path to use envvar middleware. "},{"title":"Default Config​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#default-config","content":"app.Use(&quot;/expose/envvars&quot;, envvar.New())  "},{"title":"Custom Config​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#custom-config","content":"app.Use(&quot;/expose/envvars&quot;, envvar.New(envvar.Config{ ExportVars: map[string]string{&quot;testKey&quot;: &quot;&quot;, &quot;testDefaultKey&quot;: &quot;testDefaultVal&quot;}, ExcludeVars: map[string]string{&quot;excludeKey&quot;: &quot;&quot;}} }))  "},{"title":"Response​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#response","content":"Http response contract: { &quot;vars&quot;: { &quot;someEnvVariable&quot;: &quot;someValue&quot;, &quot;anotherEnvVariable&quot;: &quot;anotherValue&quot;, } }  "},{"title":"Config​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#config","content":"// Config defines the config for middleware. type Config struct { // ExportVars specifies the environment variables that should export ExportVars map[string]string // ExcludeVars specifies the environment variables that should not export ExcludeVars map[string]string }  "},{"title":"Default Config​","type":1,"pageTitle":"EnvVar","url":"/api/middleware/envvar#default-config-1","content":"Config{}  "},{"title":"ETag","type":0,"sectionRef":"#","url":"/api/middleware/etag","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/etag&quot; )  After you initiate your Fiber app, you can use the following possibilities: "},{"title":"Default Config​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#default-config","content":"app.Use(etag.New()) // Get / receives Etag: &quot;13-1831710635&quot; in response header app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Hello, World!&quot;) })  "},{"title":"Custom Config​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#custom-config","content":"app.Use(etag.New(etag.Config{ Weak: true, })) // Get / receives Etag: &quot;W/&quot;13-1831710635&quot; in response header app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Hello, World!&quot;) })  "},{"title":"Config​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Weak indicates that a weak validator is used. Weak etags are easy // to generate, but are far less useful for comparisons. Strong // validators are ideal for comparisons but can be very difficult // to generate efficiently. Weak ETag values of two representations // of the same resources might be semantically equivalent, but not // byte-for-byte identical. This means weak etags prevent caching // when byte range requests are used, but strong etags mean range // requests can still be cached. Weak bool }  "},{"title":"Default Config​","type":1,"pageTitle":"ETag","url":"/api/middleware/etag#default-config-1","content":"var ConfigDefault = Config{ Next: nil, Weak: false, }  "},{"title":"ExpVar","type":0,"sectionRef":"#","url":"/api/middleware/expvar","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"ExpVar","url":"/api/middleware/expvar#signatures","content":"func New() fiber.Handler  "},{"title":"Example​","type":1,"pageTitle":"ExpVar","url":"/api/middleware/expvar#example","content":"Import the expvar package that is part of the Fiber web framework package main import ( &quot;expvar&quot; &quot;fmt&quot; &quot;github.com/gofiber/fiber/v2&quot; expvarmw &quot;github.com/gofiber/fiber/v2/middleware/expvar&quot; ) var count = expvar.NewInt(&quot;count&quot;) func main() { app := fiber.New() app.Use(expvarmw.New()) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { count.Add(1) return c.SendString(fmt.Sprintf(&quot;hello expvar count %d&quot;, count.Value())) }) fmt.Println(app.Listen(&quot;:3000&quot;)) }  Visit path /debug/vars to see all vars and use query r=key to filter exposed variables. curl 127.0.0.1:3000 hello expvar count 1 curl 127.0.0.1:3000/debug/vars { &quot;cmdline&quot;: [&quot;xxx&quot;], &quot;count&quot;: 1, &quot;expvarHandlerCalls&quot;: 33, &quot;expvarRegexpErrors&quot;: 0, &quot;memstats&quot;: {...} } curl 127.0.0.1:3000/debug/vars?r=c { &quot;cmdline&quot;: [&quot;xxx&quot;], &quot;count&quot;: 1 }  "},{"title":"Config​","type":1,"pageTitle":"ExpVar","url":"/api/middleware/expvar#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool }  "},{"title":"Default Config​","type":1,"pageTitle":"ExpVar","url":"/api/middleware/expvar#default-config","content":"var ConfigDefault = Config{ Next: nil, }  "},{"title":"Favicon","type":0,"sectionRef":"#","url":"/api/middleware/favicon","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Favicon","url":"/api/middleware/favicon#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Favicon","url":"/api/middleware/favicon#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/favicon&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Provide a minimal config app.Use(favicon.New()) // Or extend your config for customization app.Use(favicon.New(favicon.Config{ File: &quot;./favicon.ico&quot;, }))  "},{"title":"Config​","type":1,"pageTitle":"Favicon","url":"/api/middleware/favicon#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // File holds the path to an actual favicon that will be cached // // Optional. Default: &quot;&quot; File string }  "},{"title":"Default Config​","type":1,"pageTitle":"Favicon","url":"/api/middleware/favicon#default-config","content":"var ConfigDefault = Config{ Next: nil, File: &quot;&quot; }  "},{"title":"🧠 Ctx","type":0,"sectionRef":"#","url":"/api/ctx","content":"","keywords":""},{"title":"Accepts​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#accepts","content":"Checks, if the specified extensions or content types are acceptable. info Based on the request’s Accept HTTP header. Signature func (c *Ctx) Accepts(offers ...string) string func (c *Ctx) AcceptsCharsets(offers ...string) string func (c *Ctx) AcceptsEncodings(offers ...string) string func (c *Ctx) AcceptsLanguages(offers ...string) string  Example // Accept: text/*, application/json app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Accepts(&quot;html&quot;) // &quot;html&quot; c.Accepts(&quot;text/html&quot;) // &quot;text/html&quot; c.Accepts(&quot;json&quot;, &quot;text&quot;) // &quot;json&quot; c.Accepts(&quot;application/json&quot;) // &quot;application/json&quot; c.Accepts(&quot;image/png&quot;) // &quot;&quot; c.Accepts(&quot;png&quot;) // &quot;&quot; // ... })  Fiber provides similar functions for the other accept headers. // Accept-Charset: utf-8, iso-8859-1;q=0.2 // Accept-Encoding: gzip, compress;q=0.2 // Accept-Language: en;q=0.8, nl, ru app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.AcceptsCharsets(&quot;utf-16&quot;, &quot;iso-8859-1&quot;) // &quot;iso-8859-1&quot; c.AcceptsEncodings(&quot;compress&quot;, &quot;br&quot;) // &quot;compress&quot; c.AcceptsLanguages(&quot;pt&quot;, &quot;nl&quot;, &quot;ru&quot;) // &quot;nl&quot; // ... })  "},{"title":"AllParams​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#allparams","content":"Params is used to get all route parameters. Using Params method to get params. Signature func (c *Ctx) AllParams() map[string]string  Example // GET http://example.com/user/fenny app.Get(&quot;/user/:name&quot;, func(c *fiber.Ctx) error { c.AllParams() // &quot;{&quot;name&quot;: &quot;fenny&quot;}&quot; // ... }) // GET http://example.com/user/fenny/123 app.Get(&quot;/user/*&quot;, func(c *fiber.Ctx) error { c.AllParams() // &quot;{&quot;*1&quot;: &quot;fenny/123&quot;}&quot; // ... })  "},{"title":"App​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#app","content":"Returns the *App reference so you could easily access all application settings. Signature func (c *Ctx) App() *App  Example app.Get(&quot;/stack&quot;, func(c *fiber.Ctx) error { return c.JSON(c.App().Stack()) })  "},{"title":"Append​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#append","content":"Appends the specified value to the HTTP response header field. caution If the header is not already set, it creates the header with the specified value. Signature func (c *Ctx) Append(field string, values ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Append(&quot;Link&quot;, &quot;http://google.com&quot;, &quot;http://localhost&quot;) // =&gt; Link: http://localhost, http://google.com c.Append(&quot;Link&quot;, &quot;Test&quot;) // =&gt; Link: http://localhost, http://google.com, Test // ... })  "},{"title":"Attachment​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#attachment","content":"Sets the HTTP response Content-Disposition header field to attachment. Signature func (c *Ctx) Attachment(filename ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Attachment() // =&gt; Content-Disposition: attachment c.Attachment(&quot;./upload/images/logo.png&quot;) // =&gt; Content-Disposition: attachment; filename=&quot;logo.png&quot; // =&gt; Content-Type: image/png // ... })  "},{"title":"BaseURL​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#baseurl","content":"Returns the base URL (protocol + host) as a string. Signature func (c *Ctx) BaseURL() string  Example // GET https://example.com/page#chapter-1 app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.BaseURL() // https://example.com // ... })  "},{"title":"Bind​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#bind","content":"Add vars to default view var map binding to template engine. Variables are read by the Render method and may be overwritten. Signature func (c *Ctx) Bind(vars Map) error  Example app.Use(func(c *fiber.Ctx) error { c.Bind(fiber.Map{ &quot;Title&quot;: &quot;Hello, World!&quot;, }) }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Render(&quot;xxx.tmpl&quot;, fiber.Map{}) // Render will use Title variable })  "},{"title":"Body​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#body","content":"Returns the raw request body. Signature func (c *Ctx) Body() []byte  Example // curl -X POST http://localhost:8080 -d user=john app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Get raw body from POST request: return c.Send(c.Body()) // []byte(&quot;user=john&quot;) })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"BodyParser​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#bodyparser","content":"Binds the request body to a struct. It is important to specify the correct struct tag based on the content type to be parsed. For example, if you want to parse a JSON body with a field called Pass, you would use a struct field of json:&quot;pass&quot;. content-type\tstruct tagapplication/x-www-form-urlencoded\tform multipart/form-data\tform application/json\tjson application/xml\txml text/xml\txml Signature func (c *Ctx) BodyParser(out interface{}) error  Example // Field names should start with an uppercase letter type Person struct { Name string `json:&quot;name&quot; xml:&quot;name&quot; form:&quot;name&quot;` Pass string `json:&quot;pass&quot; xml:&quot;pass&quot; form:&quot;pass&quot;` } app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { p := new(Person) if err := c.BodyParser(p); err != nil { return err } log.Println(p.Name) // john log.Println(p.Pass) // doe // ... }) // Run tests with the following curl commands // curl -X POST -H &quot;Content-Type: application/json&quot; --data &quot;{\\&quot;name\\&quot;:\\&quot;john\\&quot;,\\&quot;pass\\&quot;:\\&quot;doe\\&quot;}&quot; localhost:3000 // curl -X POST -H &quot;Content-Type: application/xml&quot; --data &quot;&lt;login&gt;&lt;name&gt;john&lt;/name&gt;&lt;pass&gt;doe&lt;/pass&gt;&lt;/login&gt;&quot; localhost:3000 // curl -X POST -H &quot;Content-Type: application/x-www-form-urlencoded&quot; --data &quot;name=john&amp;pass=doe&quot; localhost:3000 // curl -X POST -F name=john -F pass=doe http://localhost:3000 // curl -X POST &quot;http://localhost:3000/?name=john&amp;pass=doe&quot;  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"ClearCookie​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#clearcookie","content":"Expire a client cookie (or all cookies if left empty) Signature func (c *Ctx) ClearCookie(key ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Clears all cookies: c.ClearCookie() // Expire specific cookie by name: c.ClearCookie(&quot;user&quot;) // Expire multiple cookies by names: c.ClearCookie(&quot;token&quot;, &quot;session&quot;, &quot;track_id&quot;, &quot;version&quot;) // ... })  caution Web browsers and other compliant clients will only clear the cookie if the given options are identical to those when creating the cookie, excluding expires and maxAge. ClearCookie will not set these values for you - a technique similar to the one shown below should be used to ensure your cookie is deleted. Example app.Get(&quot;/set&quot;, func(c *fiber.Ctx) error { c.Cookie(&amp;fiber.Cookie{ Name: &quot;token&quot;, Value: &quot;randomvalue&quot;, Expires: time.Now().Add(24 * time.Hour), HTTPOnly: true, SameSite: &quot;lax&quot;, }) // ... }) app.Get(&quot;/delete&quot;, func(c *fiber.Ctx) error { c.Cookie(&amp;fiber.Cookie{ Name: &quot;token&quot;, // Set expiry date to the past Expires: time.Now().Add(-(time.Hour * 2)), HTTPOnly: true, SameSite: &quot;lax&quot;, }) // ... })  "},{"title":"ClientHelloInfo​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#clienthelloinfo","content":"ClientHelloInfo contains information from a ClientHello message in order to guide application logic in the GetCertificate and GetConfigForClient callbacks. You can refer to the ClientHelloInfo struct documentation for more information on the returned struct. Signature func (c *Ctx) ClientHelloInfo() *tls.ClientHelloInfo  Example // GET http://example.com/hello app.Get(&quot;/hello&quot;, func(c *fiber.Ctx) error { chi := c.ClientHelloInfo() // ... })  "},{"title":"Context​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#context","content":"Returns *fasthttp.RequestCtx that is compatible with the context.Context interface that requires a deadline, a cancellation signal, and other values across API boundaries. Signature func (c *Ctx) Context() *fasthttp.RequestCtx  info Please read the Fasthttp Documentation for more information. "},{"title":"Cookie​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#cookie","content":"Set cookie Signature func (c *Ctx) Cookie(cookie *Cookie)  type Cookie struct { Name string `json:&quot;name&quot;` Value string `json:&quot;value&quot;` Path string `json:&quot;path&quot;` Domain string `json:&quot;domain&quot;` MaxAge int `json:&quot;max_age&quot;` Expires time.Time `json:&quot;expires&quot;` Secure bool `json:&quot;secure&quot;` HTTPOnly bool `json:&quot;http_only&quot;` SameSite string `json:&quot;same_site&quot;` SessionOnly bool `json:&quot;session_only&quot;` }  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Create cookie cookie := new(fiber.Cookie) cookie.Name = &quot;john&quot; cookie.Value = &quot;doe&quot; cookie.Expires = time.Now().Add(24 * time.Hour) // Set cookie c.Cookie(cookie) // ... })  "},{"title":"Cookies​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#cookies","content":"Get cookie value by key, you could pass an optional default value that will be returned if the cookie key does not exist. Signature func (c *Ctx) Cookies(key string, defaultValue ...string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Get cookie by key: c.Cookies(&quot;name&quot;) // &quot;john&quot; c.Cookies(&quot;empty&quot;, &quot;doe&quot;) // &quot;doe&quot; // ... })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Download​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#download","content":"Transfers the file from path as an attachment. Typically, browsers will prompt the user to download. By default, the Content-Disposition header filename= parameter is the file path (this typically appears in the browser dialog). Override this default with the filename parameter. Signature func (c *Ctx) Download(file string, filename ...string) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Download(&quot;./files/report-12345.pdf&quot;); // =&gt; Download report-12345.pdf return c.Download(&quot;./files/report-12345.pdf&quot;, &quot;report.pdf&quot;); // =&gt; Download report.pdf })  "},{"title":"Format​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#format","content":"Performs content-negotiation on the Accept HTTP header. It uses Accepts to select a proper format. info If the header is not specified or there is no proper format, text/plain is used. Signature func (c *Ctx) Format(body interface{}) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Accept: text/plain c.Format(&quot;Hello, World!&quot;) // =&gt; Hello, World! // Accept: text/html c.Format(&quot;Hello, World!&quot;) // =&gt; &lt;p&gt;Hello, World!&lt;/p&gt; // Accept: application/json c.Format(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; // .. })  "},{"title":"FormFile​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#formfile","content":"MultipartForm files can be retrieved by name, the first file from the given key is returned. Signature func (c *Ctx) FormFile(key string) (*multipart.FileHeader, error)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Get first file from form field &quot;document&quot;: file, err := c.FormFile(&quot;document&quot;) // Save file to root directory: return c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)) })  "},{"title":"FormValue​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#formvalue","content":"Any form values can be retrieved by name, the first value from the given key is returned. Signature func (c *Ctx) FormValue(key string, defaultValue ...string) string  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Get first value from form field &quot;name&quot;: c.FormValue(&quot;name&quot;) // =&gt; &quot;john&quot; or &quot;&quot; if not exist // .. })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Fresh​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#fresh","content":"https://expressjs.com/en/4x/api.html#req.fresh Signature func (c *Ctx) Fresh() bool  "},{"title":"Get​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#get","content":"Returns the HTTP request header specified by the field. tip The match is case-insensitive. Signature func (c *Ctx) Get(key string, defaultValue ...string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Get(&quot;Content-Type&quot;) // &quot;text/plain&quot; c.Get(&quot;CoNtEnT-TypE&quot;) // &quot;text/plain&quot; c.Get(&quot;something&quot;, &quot;john&quot;) // &quot;john&quot; // .. })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"GetReqHeaders​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#getreqheaders","content":"Returns the HTTP request headers. Signature func (c *Ctx) GetReqHeaders() map[string]string  "},{"title":"GetRespHeader​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#getrespheader","content":"Returns the HTTP response header specified by the field. tip The match is case-insensitive. Signature func (c *Ctx) GetRespHeader(key string, defaultValue ...string) string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.GetRespHeader(&quot;X-Request-Id&quot;) // &quot;8d7ad5e3-aaf3-450b-a241-2beb887efd54&quot; c.GetRespHeader(&quot;Content-Type&quot;) // &quot;text/plain&quot; c.GetRespHeader(&quot;something&quot;, &quot;john&quot;) // &quot;john&quot; // .. })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"GetRespHeaders​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#getrespheaders","content":"Returns the HTTP response headers. Signature func (c *Ctx) GetRespHeaders() map[string]string  "},{"title":"GetRouteURL​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#getrouteurl","content":"Generates URLs to named routes, with parameters. URLs are relative, for example: &quot;/user/1831&quot; Signature func (c *Ctx) GetRouteURL(routeName string, params Map) (string, error)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Home page&quot;) }).Name(&quot;home&quot;) app.Get(&quot;/user/:id&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;id&quot;)) }).Name(&quot;user.show&quot;) app.Get(&quot;/test&quot;, func(c *fiber.Ctx) error { location, _ := c.GetRouteURL(&quot;user.show&quot;, fiber.Map{&quot;id&quot;: 1}) return c.SendString(location) }) // /test returns &quot;/user/1&quot;  "},{"title":"Hostname​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#hostname","content":"Returns the hostname derived from the Host HTTP header. Signature func (c *Ctx) Hostname() string  Example // GET http://google.com/search app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Hostname() // &quot;google.com&quot; // ... })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"IP​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#ip","content":"Returns the remote IP address of the request. Signature func (c *Ctx) IP() string  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.IP() // &quot;127.0.0.1&quot; // ... })  "},{"title":"IPs​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#ips","content":"Returns an array of IP addresses specified in the X-Forwarded-For request header. Signature func (c *Ctx) IPs() []string  Example // X-Forwarded-For: proxy1, 127.0.0.1, proxy3 app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.IPs() // [&quot;proxy1&quot;, &quot;127.0.0.1&quot;, &quot;proxy3&quot;] // ... })  "},{"title":"Is​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#is","content":"Returns the matching content type, if the incoming request’s Content-Type HTTP header field matches the MIME type specified by the type parameter. info If the request has no body, it returns false. Signature func (c *Ctx) Is(extension string) bool  Example // Content-Type: text/html; charset=utf-8 app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Is(&quot;html&quot;) // true c.Is(&quot;.html&quot;) // true c.Is(&quot;json&quot;) // false // ... })  "},{"title":"IsFromLocal​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#isfromlocal","content":"Returns true if request came from localhost Signature func (c *Ctx) IsFromLocal() bool {  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // If request came from localhost, return true else return false c.isFromLocal() // ... })  "},{"title":"JSON​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#json","content":"Converts any interface or string to JSON using the goccy/go-json package. info JSON also sets the content header to application/json. Signature func (c *Ctx) JSON(data interface{}) error  Example type SomeStruct struct { Name string Age uint8 } app.Get(&quot;/json&quot;, func(c *fiber.Ctx) error { // Create data struct: data := SomeStruct{ Name: &quot;Grame&quot;, Age: 20, } return c.JSON(data) // =&gt; Content-Type: application/json // =&gt; &quot;{&quot;Name&quot;: &quot;Grame&quot;, &quot;Age&quot;: 20}&quot; return c.JSON(fiber.Map{ &quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20, }) // =&gt; Content-Type: application/json // =&gt; &quot;{&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}&quot; })  "},{"title":"JSONP​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#jsonp","content":"Sends a JSON response with JSONP support. This method is identical to JSON, except that it opts-in to JSONP callback support. By default, the callback name is simply callback. Override this by passing a named string in the method. Signature func (c *Ctx) JSONP(data interface{}, callback ...string) error  Example type SomeStruct struct { name string age uint8 } app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Create data struct: data := SomeStruct{ name: &quot;Grame&quot;, age: 20, } return c.JSONP(data) // =&gt; callback({&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}) return c.JSONP(data, &quot;customFunc&quot;) // =&gt; customFunc({&quot;name&quot;: &quot;Grame&quot;, &quot;age&quot;: 20}) })  "},{"title":"Links​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#links","content":"Joins the links followed by the property to populate the response’s Link HTTP header field. Signature func (c *Ctx) Links(link ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Links( &quot;http://api.example.com/users?page=2&quot;, &quot;next&quot;, &quot;http://api.example.com/users?page=5&quot;, &quot;last&quot;, ) // Link: &lt;http://api.example.com/users?page=2&gt;; rel=&quot;next&quot;, // &lt;http://api.example.com/users?page=5&gt;; rel=&quot;last&quot; // ... })  "},{"title":"Locals​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#locals","content":"A method that stores variables scoped to the request and, therefore, are available only to the routes that match the request. tip This is useful if you want to pass some specific data to the next middleware. Signature func (c *Ctx) Locals(key string, value ...interface{}) interface{}  Example app.Use(func(c *fiber.Ctx) error { c.Locals(&quot;user&quot;, &quot;admin&quot;) return c.Next() }) app.Get(&quot;/admin&quot;, func(c *fiber.Ctx) error { if c.Locals(&quot;user&quot;) == &quot;admin&quot; { return c.Status(fiber.StatusOK).SendString(&quot;Welcome, admin!&quot;) } return c.SendStatus(fiber.StatusForbidden) })  "},{"title":"Location​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#location","content":"Sets the response Location HTTP header to the specified path parameter. Signature func (c *Ctx) Location(path string)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { c.Location(&quot;http://example.com&quot;) c.Location(&quot;/foo/bar&quot;) return nil })  "},{"title":"Method​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#method","content":"Returns a string corresponding to the HTTP method of the request: GET, POST, PUT, and so on. Optionally, you could override the method by passing a string. Signature func (c *Ctx) Method(override ...string) string  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { c.Method() // &quot;POST&quot; c.Method(&quot;GET&quot;) c.Method() // GET // ... })  "},{"title":"MultipartForm​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#multipartform","content":"To access multipart form entries, you can parse the binary with MultipartForm(). This returns a map[string][]string, so given a key, the value will be a string slice. Signature func (c *Ctx) MultipartForm() (*multipart.Form, error)  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Parse the multipart form: if form, err := c.MultipartForm(); err == nil { // =&gt; *multipart.Form if token := form.Value[&quot;token&quot;]; len(token) &gt; 0 { // Get key value: fmt.Println(token[0]) } // Get all files from &quot;documents&quot; key: files := form.File[&quot;documents&quot;] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[&quot;Content-Type&quot;][0]) // =&gt; &quot;tutorial.pdf&quot; 360641 &quot;application/pdf&quot; // Save the files to disk: if err := c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)); err != nil { return err } } } return err })  "},{"title":"Next​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#next","content":"When Next is called, it executes the next method in the stack that matches the current route. You can pass an error struct within the method that will end the chaining and call the error handler. Signature func (c *Ctx) Next() error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { fmt.Println(&quot;1st route!&quot;) return c.Next() }) app.Get(&quot;*&quot;, func(c *fiber.Ctx) error { fmt.Println(&quot;2nd route!&quot;) return c.Next() }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { fmt.Println(&quot;3rd route!&quot;) return c.SendString(&quot;Hello, World!&quot;) })  "},{"title":"OriginalURL​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#originalurl","content":"Returns the original request URL. Signature func (c *Ctx) OriginalURL() string  Example // GET http://example.com/search?q=something app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.OriginalURL() // &quot;/search?q=something&quot; // ... })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"Params​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#params","content":"Method can be used to get the route parameters, you could pass an optional default value that will be returned if the param key does not exist. info Defaults to empty string (&quot;&quot;), if the param doesn't exist. Signature func (c *Ctx) Params(key string, defaultValue ...string) string  Example // GET http://example.com/user/fenny app.Get(&quot;/user/:name&quot;, func(c *fiber.Ctx) error { c.Params(&quot;name&quot;) // &quot;fenny&quot; // ... }) // GET http://example.com/user/fenny/123 app.Get(&quot;/user/*&quot;, func(c *fiber.Ctx) error { c.Params(&quot;*&quot;) // &quot;fenny/123&quot; c.Params(&quot;*1&quot;) // &quot;fenny/123&quot; // ... })  Unnamed route parameters(*, +) can be fetched by the character and the counter in the route. Example // ROUTE: /v1/*/shop/* // GET: /v1/brand/4/shop/blue/xs c.Params(&quot;*1&quot;) // &quot;brand/4&quot; c.Params(&quot;*2&quot;) // &quot;blue/xs&quot;  For reasons of downward compatibility, the first parameter segment for the parameter character can also be accessed without the counter. Example app.Get(&quot;/v1/*/shop/*&quot;, func(c *fiber.Ctx) error { c.Params(&quot;*&quot;) // outputs the values of the first wildcard segment })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"ParamsInt​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#paramsint","content":"Method can be used to get an integer from the route parameters. Please note if that parameter is not in the request, zero will be returned. If the parameter is NOT a number, zero and an error will be returned info Defaults to the integer zero (0), if the param doesn't exist. Signature func (c *Ctx) ParamsInt(key string) (int, error)  Example // GET http://example.com/user/123 app.Get(&quot;/user/:id&quot;, func(c *fiber.Ctx) error { id, err := c.ParamsInt(&quot;id&quot;) // int 123 and no error // ... })  This method is equivalent of using atoi with ctx.Params "},{"title":"ParamsParser​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#paramsparser","content":"This method is similar to BodyParser, but for path parameters. It is important to use the struct tag &quot;params&quot;. For example, if you want to parse a path parameter with a field called Pass, you would use a struct field of params:&quot;pass&quot; Signature func (c *Ctx) ParamsParser(out interface{}) error  Example // GET http://example.com/user/111 app.Get(&quot;/user/:id&quot;, func(c *fiber.Ctx) error { param := struct {ID uint `params:&quot;id&quot;`}{} c.ParamsParser(&amp;param) // &quot;{&quot;id&quot;: 111}&quot; // ... })  "},{"title":"Path​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#path","content":"Contains the path part of the request URL. Optionally, you could override the path by passing a string. For internal redirects, you might want to call RestartRouting instead of Next. Signature func (c *Ctx) Path(override ...string) string  Example // GET http://example.com/users?sort=desc app.Get(&quot;/users&quot;, func(c *fiber.Ctx) error { c.Path() // &quot;/users&quot; c.Path(&quot;/john&quot;) c.Path() // &quot;/john&quot; // ... })  "},{"title":"Protocol​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#protocol","content":"Contains the request protocol string: http or https for TLS requests. Signature func (c *Ctx) Protocol() string  Example // GET http://example.com app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Protocol() // &quot;http&quot; // ... })  "},{"title":"Query​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#query","content":"This property is an object containing a property for each query string parameter in the route, you could pass an optional default value that will be returned if the query key does not exist. info If there is no query string, it returns an empty string. Signature func (c *Ctx) Query(key string, defaultValue ...string) string  Example // GET http://example.com/shoes?order=desc&amp;brand=nike app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Query(&quot;order&quot;) // &quot;desc&quot; c.Query(&quot;brand&quot;) // &quot;nike&quot; c.Query(&quot;empty&quot;, &quot;nike&quot;) // &quot;nike&quot; // ... })  Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more... "},{"title":"QueryParser​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#queryparser","content":"This method is similar to BodyParser, but for query parameters. It is important to use the struct tag &quot;query&quot;. For example, if you want to parse a query parameter with a field called Pass, you would use a struct field of query:&quot;pass&quot;. Signature func (c *Ctx) QueryParser(out interface{}) error  Example // Field names should start with an uppercase letter type Person struct { Name string `query:&quot;name&quot;` Pass string `query:&quot;pass&quot;` Products []string `query:&quot;products&quot;` } app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { p := new(Person) if err := c.QueryParser(p); err != nil { return err } log.Println(p.Name) // john log.Println(p.Pass) // doe log.Println(p.Products) // [shoe, hat] // ... }) // Run tests with the following curl command // curl &quot;http://localhost:3000/?name=john&amp;pass=doe&amp;products=shoe,hat&quot;  "},{"title":"Range​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#range","content":"A struct containing the type and a slice of ranges will be returned. Signature func (c *Ctx) Range(size int) (Range, error)  Example // Range: bytes=500-700, 700-900 app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { b := c.Range(1000) if b.Type == &quot;bytes&quot; { for r := range r.Ranges { fmt.Println(r) // [500, 700] } } })  "},{"title":"Redirect​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#redirect","content":"Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an HTTP status code. info If not specified, status defaults to 302 Found. Signature func (c *Ctx) Redirect(location string, status ...int) error  Example app.Get(&quot;/coffee&quot;, func(c *fiber.Ctx) error { return c.Redirect(&quot;/teapot&quot;) }) app.Get(&quot;/teapot&quot;, func(c *fiber.Ctx) error { return c.Status(fiber.StatusTeapot).Send(&quot;🍵 short and stout 🍵&quot;) })  {% code title=&quot;More examples&quot; %} app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Redirect(&quot;/foo/bar&quot;) return c.Redirect(&quot;../login&quot;) return c.Redirect(&quot;http://example.com&quot;) return c.Redirect(&quot;http://example.com&quot;, 301) })  "},{"title":"RedirectToRoute​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#redirecttoroute","content":"Redirects to the specific route along with the parameters and with specified status, a positive integer that corresponds to an HTTP status code. info If not specified, status defaults to 302 Found. info If you want to send queries to route, you must add &quot;queries&quot; key typed as map[string]string to params. Signature func (c *Ctx) RedirectToRoute(routeName string, params fiber.Map, status ...int) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // /user/fiber return c.RedirectToRoute(&quot;user&quot;, fiber.Map{ &quot;name&quot;: &quot;fiber&quot; }) }) app.Get(&quot;/with-queries&quot;, func(c *fiber.Ctx) error { // /user/fiber?data[0][name]=john&amp;data[0][age]=10&amp;test=doe return c.RedirectToRoute(&quot;user&quot;, fiber.Map{ &quot;name&quot;: &quot;fiber&quot;, &quot;queries&quot;: map[string]string{&quot;data[0][name]&quot;: &quot;john&quot;, &quot;data[0][age]&quot;: &quot;10&quot;, &quot;test&quot;: &quot;doe&quot;}, }) }) app.Get(&quot;/user/:name&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;name&quot;)) }).Name(&quot;user&quot;)  "},{"title":"RedirectBack​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#redirectback","content":"Redirects back to refer URL. It redirects to fallback URL if refer header doesn't exists, with specified status, a positive integer that corresponds to an HTTP status code. info If not specified, status defaults to 302 Found. Signature func (c *Ctx) RedirectBack(fallback string, status ...int) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Home page&quot;) }) app.Get(&quot;/test&quot;, func(c *fiber.Ctx) error { c.Set(&quot;Content-Type&quot;, &quot;text/html&quot;) return c.SendString(`&lt;a href=&quot;/back&quot;&gt;Back&lt;/a&gt;`) }) app.Get(&quot;/back&quot;, func(c *fiber.Ctx) error { return c.RedirectBack(&quot;/&quot;) })  "},{"title":"Render​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#render","content":"Renders a view with data and sends a text/html response. By default Render uses the default Go Template engine. If you want to use another View engine, please take a look at our Template middleware. Signature func (c *Ctx) Render(name string, bind interface{}, layouts ...string) error  "},{"title":"Request​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#request","content":"Request return the *fasthttp.Request pointer Signature func (c *Ctx) Request() *fasthttp.Request  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Request().Header.Method() // =&gt; []byte(&quot;GET&quot;) })  "},{"title":"ReqHeaderParser​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#reqheaderparser","content":"This method is similar to BodyParser, but for request headers. It is important to use the struct tag &quot;reqHeader&quot;. For example, if you want to parse a request header with a field called Pass, you would use a struct field of reqHeader:&quot;pass&quot;. Signature func (c *Ctx) ReqHeaderParser(out interface{}) error  Example // Field names should start with an uppercase letter type Person struct { Name string `reqHeader:&quot;name&quot;` Pass string `reqHeader:&quot;pass&quot;` Products []string `reqHeader:&quot;products&quot;` } app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { p := new(Person) if err := c.ReqHeaderParser(p); err != nil { return err } log.Println(p.Name) // john log.Println(p.Pass) // doe log.Println(p.Products) // [shoe, hat] // ... }) // Run tests with the following curl command // curl &quot;http://localhost:3000/&quot; -H &quot;name: john&quot; -H &quot;pass: doe&quot; -H &quot;products: shoe,hat&quot;  "},{"title":"Response​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#response","content":"Response return the *fasthttp.Response pointer Signature func (c *Ctx) Response() *fasthttp.Response  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Response().BodyWriter().Write([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; return nil })  "},{"title":"RestartRouting​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#restartrouting","content":"Instead of executing the next method when calling Next, RestartRouting restarts execution from the first method that matches the current route. This may be helpful after overriding the path, i. e. an internal redirect. Note that handlers might be executed again which could result in an infinite loop. Signature func (c *Ctx) RestartRouting() error  Example app.Get(&quot;/new&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;From /new&quot;) }) app.Get(&quot;/old&quot;, func(c *fiber.Ctx) error { c.Path(&quot;/new&quot;) return c.RestartRouting() })  "},{"title":"Route​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#route","content":"Returns the matched Route struct. Signature func (c *Ctx) Route() *Route  Example // http://localhost:8080/hello app.Get(&quot;/hello/:name&quot;, func(c *fiber.Ctx) error { r := c.Route() fmt.Println(r.Method, r.Path, r.Params, r.Handlers) // GET /hello/:name handler [name] // ... })  caution Do not rely on c.Route() in middlewares before calling c.Next() - c.Route() returns the last executed route. Example func MyMiddleware() fiber.Handler { return func(c *fiber.Ctx) error { beforeNext := c.Route().Path // Will be '/' err := c.Next() afterNext := c.Route().Path // Will be '/hello/:name' return err } }  "},{"title":"SaveFile​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#savefile","content":"Method is used to save any multipart file to disk. Signature func (c *Ctx) SaveFile(fh *multipart.FileHeader, path string) error  Example app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Parse the multipart form: if form, err := c.MultipartForm(); err == nil { // =&gt; *multipart.Form // Get all files from &quot;documents&quot; key: files := form.File[&quot;documents&quot;] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[&quot;Content-Type&quot;][0]) // =&gt; &quot;tutorial.pdf&quot; 360641 &quot;application/pdf&quot; // Save the files to disk: if err := c.SaveFile(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename)); err != nil { return err } } return err } })  "},{"title":"SaveFileToStorage​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#savefiletostorage","content":"Method is used to save any multipart file to an external storage system. Signature func (c *Ctx) SaveFileToStorage(fileheader *multipart.FileHeader, path string, storage Storage) error  Example storage := memory.New() app.Post(&quot;/&quot;, func(c *fiber.Ctx) error { // Parse the multipart form: if form, err := c.MultipartForm(); err == nil { // =&gt; *multipart.Form // Get all files from &quot;documents&quot; key: files := form.File[&quot;documents&quot;] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[&quot;Content-Type&quot;][0]) // =&gt; &quot;tutorial.pdf&quot; 360641 &quot;application/pdf&quot; // Save the files to storage: if err := c.SaveFileToStorage(file, fmt.Sprintf(&quot;./%s&quot;, file.Filename), storage); err != nil { return err } } return err } })  "},{"title":"Secure​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#secure","content":"A boolean property that is true , if a TLS connection is established. Signature func (c *Ctx) Secure() bool  Example // Secure() method is equivalent to: c.Protocol() == &quot;https&quot;  "},{"title":"Send​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#send","content":"Sets the HTTP response body. Signature func (c *Ctx) Send(body []byte) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Send([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; })  Fiber also provides SendString and SendStream methods for raw inputs. tip Use this if you don't need type assertion, recommended for faster performance. Signature func (c *Ctx) SendString(body string) error func (c *Ctx) SendStream(stream io.Reader, size ...int) error  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; return c.SendStream(bytes.NewReader([]byte(&quot;Hello, World!&quot;))) // =&gt; &quot;Hello, World!&quot; })  "},{"title":"SendFile​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#sendfile","content":"Transfers the file from the given path. Sets the Content-Type response HTTP header field based on the filenames extension. caution Method doesn´t use gzipping by default, set it to true to enable. Signature func (c *Ctx) SendFile(file string, compress ...bool) error  Example app.Get(&quot;/not-found&quot;, func(c *fiber.Ctx) error { return c.SendFile(&quot;./public/404.html&quot;); // Disable compression return c.SendFile(&quot;./static/index.html&quot;, false); })  info If the file contains an url specific character you have to escape it before passing the file path into the sendFile function. Example app.Get(&quot;/file-with-url-chars&quot;, func(c *fiber.Ctx) error { return c.SendFile(url.PathEscape(&quot;hash_sign_#.txt&quot;)) })  "},{"title":"SendStatus​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#sendstatus","content":"Sets the status code and the correct status message in the body, if the response body is empty. tip You can find all used status codes and messages here. Signature func (c *Ctx) SendStatus(status int) error  Example app.Get(&quot;/not-found&quot;, func(c *fiber.Ctx) error { return c.SendStatus(415) // =&gt; 415 &quot;Unsupported Media Type&quot; c.SendString(&quot;Hello, World!&quot;) return c.SendStatus(415) // =&gt; 415 &quot;Hello, World!&quot; })  "},{"title":"Set​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#set","content":"Sets the response’s HTTP header field to the specified key, value. Signature func (c *Ctx) Set(key string, val string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Set(&quot;Content-Type&quot;, &quot;text/plain&quot;) // =&gt; &quot;Content-type: text/plain&quot; // ... })  "},{"title":"SetParserDecoder​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#setparserdecoder","content":"Allow you to config BodyParser/QueryParser decoder, base on schema's options, providing possibility to add custom type for pausing. Signature func SetParserDecoder(parserConfig fiber.ParserConfig{ IgnoreUnknownKeys bool, ParserType []fiber.ParserType{ Customtype interface{}, Converter func(string) reflect.Value, }, ZeroEmpty bool, SetAliasTag string, })  Example type CustomTime time.Time // String() returns the time in string func (ct *CustomTime) String() string { t := time.Time(*ct).String() return t } // Register the converter for CustomTime type format as 2006-01-02 var timeConverter = func(value string) reflect.Value { fmt.Println(&quot;timeConverter&quot;, value) if v, err := time.Parse(&quot;2006-01-02&quot;, value); err == nil { return reflect.ValueOf(v) } return reflect.Value{} } customTime := fiber.ParserType{ Customtype: CustomTime{}, Converter: timeConverter, } // Add setting to the Decoder fiber.SetParserDecoder(fiber.ParserConfig{ IgnoreUnknownKeys: true, ParserType: []fiber.ParserType{customTime}, ZeroEmpty: true, }) // Example to use CustomType, you pause custom time format not in RFC3339 type Demo struct { Date CustomTime `form:&quot;date&quot; query:&quot;date&quot;` Title string `form:&quot;title&quot; query:&quot;title&quot;` Body string `form:&quot;body&quot; query:&quot;body&quot;` } app.Post(&quot;/body&quot;, func(c *fiber.Ctx) error { var d Demo c.BodyParser(&amp;d) fmt.Println(&quot;d.Date&quot;, d.Date.String()) return c.JSON(d) }) app.Get(&quot;/query&quot;, func(c *fiber.Ctx) error { var d Demo c.QueryParser(&amp;d) fmt.Println(&quot;d.Date&quot;, d.Date.String()) return c.JSON(d) }) // curl -X POST -F title=title -F body=body -F date=2021-10-20 http://localhost:3000/body // curl -X GET &quot;http://localhost:3000/query?title=title&amp;body=body&amp;date=2021-10-20&quot;  "},{"title":"SetUserContext​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#setusercontext","content":"Sets the user specified implementation for context interface. Signature func (c *Ctx) SetUserContext(ctx context.Context)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { ctx := context.Background() c.SetUserContext(ctx) // Here ctx could be any context implementation // ... })  "},{"title":"Stale​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#stale","content":"https://expressjs.com/en/4x/api.html#req.stale Signature func (c *Ctx) Stale() bool  "},{"title":"Status​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#status","content":"Sets the HTTP status for the response. info Method is a chainable. Signature func (c *Ctx) Status(status int) *Ctx  Example app.Get(&quot;/fiber&quot;, func(c *fiber.Ctx) error { c.Status(fiber.StatusOK) return nil } app.Get(&quot;/hello&quot;, func(c *fiber.Ctx) error { return c.Status(fiber.StatusBadRequest).SendString(&quot;Bad Request&quot;) } app.Get(&quot;/world&quot;, func(c *fiber.Ctx) error { return c.Status(fiber.StatusNotFound).SendFile(&quot;./public/gopher.png&quot;) })  "},{"title":"Subdomains​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#subdomains","content":"Returns a string slice of subdomains in the domain name of the request. The application property subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments. Signature func (c *Ctx) Subdomains(offset ...int) []string  Example // Host: &quot;tobi.ferrets.example.com&quot; app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Subdomains() // [&quot;ferrets&quot;, &quot;tobi&quot;] c.Subdomains(1) // [&quot;tobi&quot;] // ... })  "},{"title":"Type​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#type","content":"Sets the Content-Type HTTP header to the MIME type listed here specified by the file extension. Signature func (c *Ctx) Type(ext string, charset ...string) *Ctx  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Type(&quot;.html&quot;) // =&gt; &quot;text/html&quot; c.Type(&quot;html&quot;) // =&gt; &quot;text/html&quot; c.Type(&quot;png&quot;) // =&gt; &quot;image/png&quot; c.Type(&quot;json&quot;, &quot;utf-8&quot;) // =&gt; &quot;application/json; charset=utf-8&quot; // ... })  "},{"title":"UserContext​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#usercontext","content":"UserContext returns a context implementation that was set by user earlier or returns a non-nil, empty context, if it was not set earlier. Signature func (c *Ctx) UserContext() context.Context  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { ctx := c.UserContext() // ctx is context implementation set by user // ... })  "},{"title":"Vary​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#vary","content":"Adds the given header field to the Vary response header. This will append the header, if not already listed, otherwise leaves it listed in the current location. info Multiple fields are allowed. Signature func (c *Ctx) Vary(fields ...string)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Vary(&quot;Origin&quot;) // =&gt; Vary: Origin c.Vary(&quot;User-Agent&quot;) // =&gt; Vary: Origin, User-Agent // No duplicates c.Vary(&quot;Origin&quot;) // =&gt; Vary: Origin, User-Agent c.Vary(&quot;Accept-Encoding&quot;, &quot;Accept&quot;) // =&gt; Vary: Origin, User-Agent, Accept-Encoding, Accept // ... })  "},{"title":"Write​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#write","content":"Write adopts the Writer interface Signature func (c *Ctx) Write(p []byte) (n int, err error)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.Write([]byte(&quot;Hello, World!&quot;)) // =&gt; &quot;Hello, World!&quot; fmt.Fprintf(c, &quot;%s\\n&quot;, &quot;Hello, World!&quot;) // &quot;Hello, World!Hello, World!&quot; })  "},{"title":"Writef​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#writef","content":"Writef adopts the string with variables Signature func (c *Ctx) Writef(f string, a ...interface{}) (n int, err error)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { world := &quot;World!&quot; c.Writef(&quot;Hello, %s&quot;, world) // =&gt; &quot;Hello, World!&quot; fmt.Fprintf(c, &quot;%s\\n&quot;, &quot;Hello, World!&quot;) // &quot;Hello, World!Hello, World!&quot; })  "},{"title":"WriteString​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#writestring","content":"WriteString adopts the string Signature func (c *Ctx) WriteString(s string) (n int, err error)  Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.WriteString(&quot;Hello, World!&quot;) // =&gt; &quot;Hello, World!&quot; fmt.Fprintf(c, &quot;%s\\n&quot;, &quot;Hello, World!&quot;) // &quot;Hello, World!Hello, World!&quot; })  "},{"title":"XHR​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#xhr","content":"A Boolean property, that is true, if the request’s X-Requested-With header field is XMLHttpRequest, indicating that the request was issued by a client library (such as jQuery). Signature func (c *Ctx) XHR() bool  Example // X-Requested-With: XMLHttpRequest app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { c.XHR() // true // ... })  "},{"title":"XML​","type":1,"pageTitle":"🧠 Ctx","url":"/api/ctx#xml","content":"Converts any interface or string to XML using the standard encoding/xml package. info XML also sets the content header to application/xml. Signature func (c *Ctx) XML(data interface{}) error  Example type SomeStruct struct { XMLName xml.Name `xml:&quot;Fiber&quot;` Name string `xml:&quot;Name&quot;` Age uint8 `xml:&quot;Age&quot;` } app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Create data struct: data := SomeStruct{ Name: &quot;Grame&quot;, Age: 20, } return c.XML(data) // &lt;Fiber&gt; // &lt;Name&gt;Grame&lt;/Name&gt; // &lt;Age&gt;20&lt;/Age&gt; // &lt;/Fiber&gt; })  "},{"title":"FileSystem","type":0,"sectionRef":"#","url":"/api/middleware/filesystem","content":"","keywords":""},{"title":"Table of Contents​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#table-of-contents","content":"SignaturesExamplesConfigDefault Config "},{"title":"Signatures​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#signatures","content":"func New(config Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Provide a minimal config app.Use(filesystem.New(filesystem.Config{ Root: http.Dir(&quot;./assets&quot;) })) // Or extend your config for customization app.Use(filesystem.New(filesystem.Config{ Root: http.Dir(&quot;./assets&quot;), Browse: true, Index: &quot;index.html&quot;, NotFoundFile: &quot;404.html&quot;, MaxAge: 3600, }))  "},{"title":"pkger​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#pkger","content":"https://github.com/markbates/pkger package main import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; &quot;github.com/markbates/pkger&quot; ) func main() { app := fiber.New() app.Use(&quot;/assets&quot;, filesystem.New(filesystem.Config{ Root: pkger.Dir(&quot;/assets&quot;), }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"packr​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#packr","content":"https://github.com/gobuffalo/packr package main import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; &quot;github.com/gobuffalo/packr/v2&quot; ) func main() { app := fiber.New() app.Use(&quot;/assets&quot;, filesystem.New(filesystem.Config{ Root: packr.New(&quot;Assets Box&quot;, &quot;/assets&quot;), }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"go.rice​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#gorice","content":"https://github.com/GeertJohan/go.rice package main import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; &quot;github.com/GeertJohan/go.rice&quot; ) func main() { app := fiber.New() app.Use(&quot;/assets&quot;, filesystem.New(filesystem.Config{ Root: rice.MustFindBox(&quot;assets&quot;).HTTPBox(), }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"fileb0x​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#fileb0x","content":"https://github.com/UnnoTed/fileb0x package main import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; &quot;&lt;Your go module&gt;/myEmbeddedFiles&quot; ) func main() { app := fiber.New() app.Use(&quot;/assets&quot;, filesystem.New(filesystem.Config{ Root: myEmbeddedFiles.HTTP, }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"statik​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#statik","content":"https://github.com/rakyll/statik package main import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/filesystem&quot; &quot;&lt;Your go module&gt;/statik&quot; fs &quot;github.com/rakyll/statik/fs&quot; ) func main() { statik, err := fs.New() if err != nil { panic(err) } app := fiber.New() app.Use(&quot;/&quot;, filesystem.New(filesystem.Config{ Root: statikFS, }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"Config​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Root is a FileSystem that provides access // to a collection of files and directories. // // Required. Default: nil Root http.FileSystem `json:&quot;-&quot;` // Enable directory browsing. // // Optional. Default: false Browse bool `json:&quot;browse&quot;` // Index file for serving a directory. // // Optional. Default: &quot;index.html&quot; Index string `json:&quot;index&quot;` // The value for the Cache-Control HTTP-header // that is set on the file response. MaxAge is defined in seconds. // // Optional. Default value 0. MaxAge int `json:&quot;max_age&quot;` // File to return if path is not found. Useful for SPA's. // // Optional. Default: &quot;&quot; NotFoundFile string `json:&quot;not_found_file&quot;` }  "},{"title":"Default Config​","type":1,"pageTitle":"FileSystem","url":"/api/middleware/filesystem#default-config","content":"var ConfigDefault = Config{ Next: nil, Root: nil, Browse: false, Index: &quot;/index.html&quot;, MaxAge: 0, }  "},{"title":"Limiter","type":0,"sectionRef":"#","url":"/api/middleware/limiter","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Limiter","url":"/api/middleware/limiter#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Limiter","url":"/api/middleware/limiter#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/limiter&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware config app.Use(limiter.New()) // Or extend your config for customization app.Use(limiter.New(limiter.Config{ Next: func(c *fiber.Ctx) bool { return c.IP() == &quot;127.0.0.1&quot; }, Max: 20, Expiration: 30 * time.Second, KeyGenerator: func(c *fiber.Ctx) string { return c.Get(&quot;x-forwarded-for&quot;) }, LimitReached: func(c *fiber.Ctx) error { return c.SendFile(&quot;./toofast.html&quot;) }, Storage: myCustomStorage{} }))  "},{"title":"Sliding window​","type":1,"pageTitle":"Limiter","url":"/api/middleware/limiter#sliding-window","content":"Instead of using the standard fixed window algorithm, you can enable the sliding window algorithm. A example of such configuration is: app.Use(limiter.New(limiter.Config{ Max: 20, Expiration: 30 * time.Second, LimiterMiddleware: limiter.SlidingWindow{} }))  This means that every window will take into account the previous window(if there was any). The given formula for the rate is: weightOfPreviousWindpw = previous window's amount request * (whenNewWindow / Expiration) rate = weightOfPreviousWindpw + current window's amount request.  "},{"title":"Config​","type":1,"pageTitle":"Limiter","url":"/api/middleware/limiter#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Max number of recent connections during `Expiration` seconds before sending a 429 response // // Default: 5 Max int // KeyGenerator allows you to generate custom keys, by default c.IP() is used // // Default: func(c *fiber.Ctx) string { // return c.IP() // } KeyGenerator func(*fiber.Ctx) string // Expiration is the time on how long to keep records of requests in memory // // Default: 1 * time.Minute Expiration time.Duration // LimitReached is called when a request hits the limit // // Default: func(c *fiber.Ctx) error { // return c.SendStatus(fiber.StatusTooManyRequests) // } LimitReached fiber.Handler // When set to true, requests with StatusCode &gt;= 400 won't be counted. // // Default: false SkipFailedRequests bool // When set to true, requests with StatusCode &lt; 400 won't be counted. // // Default: false SkipSuccessfulRequests bool // Store is used to store the state of the middleware // // Default: an in memory store for this process only Storage fiber.Storage // LimiterMiddleware is the struct that implements limiter middleware. // // Default: a new Fixed Window Rate Limiter LimiterMiddleware LimiterHandler }  A custom store can be used if it implements the Storage interface - more details and an example can be found in store.go. "},{"title":"Default Config​","type":1,"pageTitle":"Limiter","url":"/api/middleware/limiter#default-config","content":"var ConfigDefault = Config{ Max: 5, Expiration: 1 * time.Minute, KeyGenerator: func(c *fiber.Ctx) string { return c.IP() }, LimitReached: func(c *fiber.Ctx) error { return c.SendStatus(fiber.StatusTooManyRequests) }, SkipFailedRequests: false, SkipSuccessfulRequests: false, LimiterMiddleware: FixedWindow{}, }  "},{"title":"Logger","type":0,"sectionRef":"#","url":"/api/middleware/logger","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#examples","content":"First ensure the appropriate packages are imported import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/logger&quot; )  "},{"title":"Initialization / Default Config​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#initialization--default-config","content":"// Default middleware config app.Use(logger.New())  "},{"title":"Logging remote IP and Port​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#logging-remote-ip-and-port","content":"app.Use(logger.New(logger.Config{ Format: &quot;[${ip}]:${port} ${status} - ${method} ${path}\\n&quot;, }))  "},{"title":"Logging Request ID​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#logging-request-id","content":"app.Use(requestid.New()) app.Use(logger.New(logger.Config{ // For more options, see the Config section Format: &quot;${pid} ${locals:requestid} ${status} - ${method} ${path}\\n&quot;, }))  "},{"title":"Changing TimeZone & TimeFormat​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#changing-timezone--timeformat","content":"app.Use(logger.New(logger.Config{ Format: &quot;${pid} ${status} - ${method} ${path}\\n&quot;, TimeFormat: &quot;02-Jan-2006&quot;, TimeZone: &quot;America/New_York&quot;, }))  "},{"title":"Custom File Writer​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#custom-file-writer","content":"file, err := os.OpenFile(&quot;./123.log&quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666) if err != nil { log.Fatalf(&quot;error opening file: %v&quot;, err) } defer file.Close() app.Use(logger.New(logger.Config{ Output: file, }))  "},{"title":"Config​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Format defines the logging tags // // Optional. Default: [${time}] ${status} - ${latency} ${method} ${path}\\n Format string // TimeFormat https://programming.guide/go/format-parse-string-time-date-example.html // // Optional. Default: 15:04:05 TimeFormat string // TimeZone can be specified, such as &quot;UTC&quot; and &quot;America/New_York&quot; and &quot;Asia/Chongqing&quot;, etc // // Optional. Default: &quot;Local&quot; TimeZone string // TimeInterval is the delay before the timestamp is updated // // Optional. Default: 500 * time.Millisecond TimeInterval time.Duration // Output is a writter where logs are written // // Default: os.Stderr Output io.Writer }  "},{"title":"Default Config​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#default-config","content":"var ConfigDefault = Config{ Next: nil, Format: &quot;[${time}] ${status} - ${latency} ${method} ${path}\\n&quot;, TimeFormat: &quot;15:04:05&quot;, TimeZone: &quot;Local&quot;, TimeInterval: 500 * time.Millisecond, Output: os.Stderr, }  "},{"title":"Constants​","type":1,"pageTitle":"Logger","url":"/api/middleware/logger#constants","content":"// Logger variables const ( TagPid = &quot;pid&quot; TagTime = &quot;time&quot; TagReferer = &quot;referer&quot; TagProtocol = &quot;protocol&quot; TagPort = &quot;port&quot; TagIP = &quot;ip&quot; TagIPs = &quot;ips&quot; TagHost = &quot;host&quot; TagMethod = &quot;method&quot; TagPath = &quot;path&quot; TagURL = &quot;url&quot; TagUA = &quot;ua&quot; TagLatency = &quot;latency&quot; TagStatus = &quot;status&quot; // response status TagResBody = &quot;resBody&quot; // response body TagReqHeaders = &quot;reqHeaders&quot; TagQueryStringParams = &quot;queryParams&quot; // request query parameters TagBody = &quot;body&quot; // request body TagBytesSent = &quot;bytesSent&quot; TagBytesReceived = &quot;bytesReceived&quot; TagRoute = &quot;route&quot; TagError = &quot;error&quot; TagHeader = &quot;header:&quot; // DEPRECATED: Use TagReqHeader instead TagReqHeader = &quot;reqHeader:&quot; // request header TagRespHeader = &quot;respHeader:&quot; // response header TagQuery = &quot;query:&quot; // request query TagForm = &quot;form:&quot; // request form TagCookie = &quot;cookie:&quot; // request cookie TagLocals = &quot;locals:&quot; // colors TagBlack = &quot;black&quot; TagRed = &quot;red&quot; TagGreen = &quot;green&quot; TagYellow = &quot;yellow&quot; TagBlue = &quot;blue&quot; TagMagenta = &quot;magenta&quot; TagCyan = &quot;cyan&quot; TagWhite = &quot;white&quot; TagReset = &quot;reset&quot; )  "},{"title":"Monitor","type":0,"sectionRef":"#","url":"/api/middleware/monitor","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Monitor","url":"/api/middleware/monitor#signatures","content":"func New() fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Monitor","url":"/api/middleware/monitor#examples","content":"Import the middleware package and assign it to a route. package main import ( &quot;log&quot; &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/monitor&quot; ) func main() { app := fiber.New() app.Get(&quot;/metrics&quot;, monitor.New(monitor.Config{Title: &quot;MyService Metrics Page&quot;})) log.Fatal(app.Listen(&quot;:3000&quot;)) }  You can also access the API endpoint withcurl -X GET -H &quot;Accept: application/json&quot; http://localhost:3000/metrics which returns: {&quot;pid&quot;:{ &quot;cpu&quot;:0.4568381746582226, &quot;ram&quot;:20516864, &quot;conns&quot;:3 }, &quot;os&quot;: { &quot;cpu&quot;:8.759124087593099, &quot;ram&quot;:3997155328, &quot;conns&quot;:44, &quot;total_ram&quot;:8245489664, &quot;load_avg&quot;:0.51 }}  "},{"title":"Config​","type":1,"pageTitle":"Monitor","url":"/api/middleware/monitor#config","content":"// Config defines the config for middleware. type Config struct { // Metrics page title // // Optional. Default: &quot;Fiber Monitor&quot; Title string // Refresh period // // Optional. Default: 3 seconds Refresh time.Duration // Whether the service should expose only the monitoring API. // // Optional. Default: false APIOnly bool // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Custom HTML Code to Head Section(Before End) // // Optional. Default: empty CustomHead string // FontURL for specify font resource path or URL . also you can use relative path // // Optional. Default: https://fonts.googleapis.com/css2?family=Roboto:wght@400;900&amp;display=swap FontURL string // ChartJsURL for specify ChartJS library path or URL . also you can use relative path // // Optional. Default: https://cdn.jsdelivr.net/npm/chart.js@2.9/dist/Chart.bundle.min.js ChartJsURL string }  "},{"title":"Default Config​","type":1,"pageTitle":"Monitor","url":"/api/middleware/monitor#default-config","content":"var ConfigDefault = Config{ Title: &quot;Fiber Monitor&quot;, Refresh: 3 * time.Second, APIOnly: false, Next: nil, CustomHead:&quot;&quot;, FontURL:&quot;https://fonts.googleapis.com/css2?family=Roboto:wght@400;900&amp;display=swap&quot;, ChartJsURL:&quot;https://cdn.jsdelivr.net/npm/chart.js@2.9/dist/Chart.bundle.min.js&quot; }  "},{"title":"Pprof","type":0,"sectionRef":"#","url":"/api/middleware/pprof","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Pprof","url":"/api/middleware/pprof#signatures","content":"func New() fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Pprof","url":"/api/middleware/pprof#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/pprof&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware app.Use(pprof.New())  "},{"title":"Config​","type":1,"pageTitle":"Pprof","url":"/api/middleware/pprof#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool }  "},{"title":"Default Config​","type":1,"pageTitle":"Pprof","url":"/api/middleware/pprof#default-config","content":"var ConfigDefault = Config{ Next: nil, }  "},{"title":"Proxy","type":0,"sectionRef":"#","url":"/api/middleware/proxy","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Proxy","url":"/api/middleware/proxy#signatures","content":"func Balancer(config Config) fiber.Handler func Forward(addr string, clients ...*fasthttp.Client) fiber.Handler func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error  "},{"title":"Examples​","type":1,"pageTitle":"Proxy","url":"/api/middleware/proxy#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/proxy&quot; )  After you initiate your Fiber app, you can use the following possibilities: // if target https site uses a self-signed certificate, you should // call WithTlsConfig before Do and Forward proxy.WithTlsConfig(&amp;tls.Config{ InsecureSkipVerify: true, }) // if you need to use global self-custom client, you should use proxy.WithClient. proxy.WithClient(&amp;fasthttp.Client{ NoDefaultUserAgentHeader: true, DisablePathNormalizing: true, }) // Forward to url app.Get(&quot;/gif&quot;, proxy.Forward(&quot;https://i.imgur.com/IWaBepg.gif&quot;)) // Forward to url with local custom client app.Get(&quot;/gif&quot;, proxy.Forward(&quot;https://i.imgur.com/IWaBepg.gif&quot;, &amp;fasthttp.Client{ NoDefaultUserAgentHeader: true, DisablePathNormalizing: true, })) // Make request within handler app.Get(&quot;/:id&quot;, func(c *fiber.Ctx) error { url := &quot;https://i.imgur.com/&quot;+c.Params(&quot;id&quot;)+&quot;.gif&quot; if err := proxy.Do(c, url); err != nil { return err } // Remove Server header from response c.Response().Header.Del(fiber.HeaderServer) return nil }) // Minimal round robin balancer app.Use(proxy.Balancer(proxy.Config{ Servers: []string{ &quot;http://localhost:3001&quot;, &quot;http://localhost:3002&quot;, &quot;http://localhost:3003&quot;, }, })) // Or extend your balancer for customization app.Use(proxy.Balancer(proxy.Config{ Servers: []string{ &quot;http://localhost:3001&quot;, &quot;http://localhost:3002&quot;, &quot;http://localhost:3003&quot;, }, ModifyRequest: func(c *fiber.Ctx) error { c.Request().Header.Add(&quot;X-Real-IP&quot;, c.IP()) return nil }, ModifyResponse: func(c *fiber.Ctx) error { c.Response().Header.Del(fiber.HeaderServer) return nil }, }))  "},{"title":"Config​","type":1,"pageTitle":"Proxy","url":"/api/middleware/proxy#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Servers defines a list of &lt;scheme&gt;://&lt;host&gt; HTTP servers, // // which are used in a round-robin manner. // i.e.: &quot;https://foobar.com, http://www.foobar.com&quot; // // Required Servers []string // ModifyRequest allows you to alter the request // // Optional. Default: nil ModifyRequest fiber.Handler // ModifyResponse allows you to alter the response // // Optional. Default: nil ModifyResponse fiber.Handler // tls config for the http client. TlsConfig *tls.Config // Client is custom client when client config is complex. // Note that Servers, Timeout, WriteBufferSize, ReadBufferSize and TlsConfig // will not be used if the client are set. Client *fasthttp.LBClient }  "},{"title":"Default Config​","type":1,"pageTitle":"Proxy","url":"/api/middleware/proxy#default-config","content":"// ConfigDefault is the default config var ConfigDefault = Config{ Next: nil, }  "},{"title":"Recover","type":0,"sectionRef":"#","url":"/api/middleware/recover","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Recover","url":"/api/middleware/recover#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Recover","url":"/api/middleware/recover#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/recover&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware config app.Use(recover.New()) // This panic will be catch by the middleware app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { panic(&quot;I'm an error&quot;) })  "},{"title":"Config​","type":1,"pageTitle":"Recover","url":"/api/middleware/recover#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // EnableStackTrace enables handling stack trace // // Optional. Default: false EnableStackTrace bool // StackTraceHandler defines a function to handle stack trace // // Optional. Default: defaultStackTraceHandler StackTraceHandler func(c *fiber.Ctx, e interface{}) }  "},{"title":"Default Config​","type":1,"pageTitle":"Recover","url":"/api/middleware/recover#default-config","content":"var ConfigDefault = Config{ Next: nil, EnableStackTrace: false, StackTraceHandler: defaultStackTraceHandler, }  "},{"title":"RequestID","type":0,"sectionRef":"#","url":"/api/middleware/requestid","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"RequestID","url":"/api/middleware/requestid#signatures","content":"func New(config ...Config) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"RequestID","url":"/api/middleware/requestid#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/requestid&quot; )  After you initiate your Fiber app, you can use the following possibilities: // Default middleware config app.Use(requestid.New()) // Or extend your config for customization app.Use(requestid.New(requestid.Config{ Header: &quot;X-Custom-Header&quot;, Generator: func() string { return &quot;static-id&quot; }, }))  "},{"title":"Config​","type":1,"pageTitle":"RequestID","url":"/api/middleware/requestid#config","content":"// Config defines the config for middleware. type Config struct { // Next defines a function to skip this middleware when returned true. // // Optional. Default: nil Next func(c *fiber.Ctx) bool // Header is the header key where to get/set the unique request ID // // Optional. Default: &quot;X-Request-ID&quot; Header string // Generator defines a function to generate the unique identifier. // // Optional. Default: utils.UUID Generator func() string // ContextKey defines the key used when storing the request ID in // the locals for a specific request. // // Optional. Default: requestid ContextKey string }  "},{"title":"Default Config​","type":1,"pageTitle":"RequestID","url":"/api/middleware/requestid#default-config","content":"var ConfigDefault = Config{ Next: nil, Header: fiber.HeaderXRequestID, Generator: func() string { return utils.UUID() }, ContextKey: &quot;requestid&quot; }  "},{"title":"Session","type":0,"sectionRef":"#","url":"/api/middleware/session","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Session","url":"/api/middleware/session#signatures","content":"func New(config ...Config) *Store func (s *Store) RegisterType(i interface{}) func (s *Store) Get(c *fiber.Ctx) (*Session, error) func (s *Store) Reset() error func (s *Session) Get(key string) interface{} func (s *Session) Set(key string, val interface{}) func (s *Session) Delete(key string) func (s *Session) Destroy() error func (s *Session) Regenerate() error func (s *Session) Save() error func (s *Session) Fresh() bool func (s *Session) ID() string func (s *Session) Keys() []string  caution Storing interface{} values are limited to built-ins Go types. "},{"title":"Examples​","type":1,"pageTitle":"Session","url":"/api/middleware/session#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/session&quot; )  Then create a Fiber app with app := fiber.New(). "},{"title":"Default Configuration​","type":1,"pageTitle":"Session","url":"/api/middleware/session#default-configuration","content":"// This stores all of your app's sessions // Default middleware config store := session.New() // This panic will be catch by the middleware app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Get session from storage sess, err := store.Get(c) if err != nil { panic(err) } // Get value name := sess.Get(&quot;name&quot;) // Set key/value sess.Set(&quot;name&quot;, &quot;john&quot;) // Get all Keys keys := sess.Keys() // Delete key sess.Delete(&quot;name&quot;) // Destroy session if err := sess.Destroy(); err != nil { panic(err) } // Save session if err := sess.Save(); err != nil { panic(err) } return c.SendString(fmt.Sprintf(&quot;Welcome %v&quot;, name)) })  "},{"title":"Custom Storage/Database​","type":1,"pageTitle":"Session","url":"/api/middleware/session#custom-storagedatabase","content":"You can use any storage from our storage package. storage := sqlite3.New() // From github.com/gofiber/storage/sqlite3 store := session.New(session.Config{ Storage: storage, })  To use the the store, see the above example. "},{"title":"Config​","type":1,"pageTitle":"Session","url":"/api/middleware/session#config","content":"// Config defines the config for middleware. type Config struct { // Allowed session duration // Optional. Default value 24 * time.Hour Expiration time.Duration // Storage interface to store the session data // Optional. Default value memory.New() Storage fiber.Storage // Name of the session cookie. This cookie will store session key. // Optional. Default value &quot;session_id&quot;. CookieName string // Domain of the cookie. // Optional. Default value &quot;&quot;. CookieDomain string // Path of the cookie. // Optional. Default value &quot;&quot;. CookiePath string // Indicates if cookie is secure. // Optional. Default value false. CookieSecure bool // Indicates if cookie is HTTP only. // Optional. Default value false. CookieHTTPOnly bool // Sets the cookie SameSite attribute. // Optional. Default value &quot;Lax&quot;. CookieSameSite string // KeyGenerator generates the session key. // Optional. Default value utils.UUID KeyGenerator func() string }  "},{"title":"Default Config​","type":1,"pageTitle":"Session","url":"/api/middleware/session#default-config","content":"var ConfigDefault = Config{ Expiration: 24 * time.Hour, CookieName: &quot;session_id&quot;, KeyGenerator: utils.UUID, }  "},{"title":"Skip","type":0,"sectionRef":"#","url":"/api/middleware/skip","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Skip","url":"/api/middleware/skip#signatures","content":"func New(handler fiber.Handler, exclude func(c *fiber.Ctx) bool) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Skip","url":"/api/middleware/skip#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/skip&quot; )  After you initiate your Fiber app, you can use the following possibilities: app.Use(skip.New(handler, func(ctx *fiber.Ctx) bool { return ctx.Method() == fiber.MethodOptions }))  "},{"title":"Timeout","type":0,"sectionRef":"#","url":"/api/middleware/timeout","content":"","keywords":""},{"title":"Signatures​","type":1,"pageTitle":"Timeout","url":"/api/middleware/timeout#signatures","content":"func New(handler fiber.Handler, timeout time.Duration, timeoutErrors ...error) fiber.Handler  "},{"title":"Examples​","type":1,"pageTitle":"Timeout","url":"/api/middleware/timeout#examples","content":"Import the middleware package that is part of the Fiber web framework import ( &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/timeout&quot; )  Sample timeout middleware usage: func main() { app := fiber.New() h := func(c *fiber.Ctx) error { sleepTime, _ := time.ParseDuration(c.Params(&quot;sleepTime&quot;) + &quot;ms&quot;) if err := sleepWithContext(c.UserContext(), sleepTime); err != nil { return fmt.Errorf(&quot;%w: execution error&quot;, err) } return nil } app.Get(&quot;/foo/:sleepTime&quot;, timeout.New(h, 2*time.Second)) _ = app.Listen(&quot;:3000&quot;) } func sleepWithContext(ctx context.Context, d time.Duration) error { timer := time.NewTimer(d) select { case &lt;-ctx.Done(): if !timer.Stop() { &lt;-timer.C } return context.DeadlineExceeded case &lt;-timer.C: } return nil }  Test http 200 with curl: curl --location -I --request GET 'http://localhost:3000/foo/1000'  Test http 408 with curl: curl --location -I --request GET 'http://localhost:3000/foo/3000'  Use with custom error: var ErrFooTimeOut = errors.New(&quot;foo context canceled&quot;) func main() { app := fiber.New() h := func(c *fiber.Ctx) error { sleepTime, _ := time.ParseDuration(c.Params(&quot;sleepTime&quot;) + &quot;ms&quot;) if err := sleepWithContextWithCustomError(c.UserContext(), sleepTime); err != nil { return fmt.Errorf(&quot;%w: execution error&quot;, err) } return nil } app.Get(&quot;/foo/:sleepTime&quot;, timeout.New(h, 2*time.Second, ErrFooTimeOut)) _ = app.Listen(&quot;:3000&quot;) } func sleepWithContextWithCustomError(ctx context.Context, d time.Duration) error { timer := time.NewTimer(d) select { case &lt;-ctx.Done(): if !timer.Stop() { &lt;-timer.C } return ErrFooTimeOut case &lt;-timer.C: } return nil }  Sample usage with a DB call: func main() { app := fiber.New() db, _ := gorm.Open(postgres.Open(&quot;postgres://localhost/foodb&quot;), &amp;gorm.Config{}) handler := func(ctx *fiber.Ctx) error { tran := db.WithContext(ctx.UserContext()).Begin() if tran = tran.Exec(&quot;SELECT pg_sleep(50)&quot;); tran.Error != nil { return tran.Error } if tran = tran.Commit(); tran.Error != nil { return tran.Error } return nil } app.Get(&quot;/foo&quot;, timeout.New(handler, 10*time.Second)) app.Listen(&quot;:3000&quot;) }  "},{"title":"📊 Benchmarks","type":0,"sectionRef":"#","url":"/extra/benchmarks","content":"","keywords":""},{"title":"TechEmpower​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#techempower","content":"TechEmpower provides a performance comparison of many web application frameworks executing fundamental tasks such as JSON serialization, database access, and server-side template composition. Each framework is operating in a realistic production configuration. Results are captured on cloud instances and on physical hardware. The test implementations are largely community-contributed and all source is available at the GitHub repository. Fiber v1.10.028 HT Cores Intel(R) Xeon(R) Gold 5120 CPU @ 2.20GHz32GB RAMUbuntu 18.04.3 4.15.0-88-genericDedicated Cisco 10-Gbit Ethernet switch. "},{"title":"Plaintext​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#plaintext","content":"The Plaintext test is an exercise of the request-routing fundamentals only, designed to demonstrate the capacity of high-performance platforms in particular. Requests will be sent using HTTP pipelining. The response payload is still small, meaning good performance is still necessary in order to saturate the gigabit Ethernet of the test environment. See Plaintext requirements Fiber - 6,162,556 responses per second with an average latency of 2.0 ms. Express - 367,069 responses per second with an average latency of 354.1 ms.   "},{"title":"Data Updates​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#data-updates","content":"Fiber handled 11,846 responses per second with an average latency of 42.8 ms. Express handled 2,066 responses per second with an average latency of 390.44 ms.   "},{"title":"Multiple Queries​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#multiple-queries","content":"Fiber handled 19,664 responses per second with an average latency of 25.7 ms. Express handled 4,302 responses per second with an average latency of 117.2 ms.   "},{"title":"Single Query​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#single-query","content":"Fiber handled 368,647 responses per second with an average latency of 0.7 ms. Express handled 57,880 responses per second with an average latency of 4.4 ms.   "},{"title":"JSON Serialization​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#json-serialization","content":"Fiber handled 1,146,667 responses per second with an average latency of 0.4 ms. Express handled 244,847 responses per second with an average latency of 1.1 ms.   "},{"title":"Go web framework benchmark​","type":1,"pageTitle":"📊 Benchmarks","url":"/extra/benchmarks#go-web-framework-benchmark","content":"🔗 https://github.com/smallnest/go-web-framework-benchmark CPU Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHzMEM 4GBGO go1.13.6 linux/amd64OS Linux The first test case is to mock 0 ms, 10 ms, 100 ms, 500 ms processing time in handlers.  The concurrency clients are 5000.  Latency is the time of real processing time by web servers. The smaller is the better.  Allocs is the heap allocations by web servers when test is running. The unit is MB. The smaller is the better. If we enable http pipelining, test result as below:  Concurrency test in 30 ms processing time, the test result for 100, 1000, 5000 clients is:    If we enable http pipelining, test result as below:  Dependency graph for v1.9.0  "},{"title":"🤔 FAQ","type":0,"sectionRef":"#","url":"/extra/faq","content":"","keywords":""},{"title":"How should I structure my application?​","type":1,"pageTitle":"🤔 FAQ","url":"/extra/faq#how-should-i-structure-my-application","content":"There is no definitive answer to this question. The answer depends on the scale of your application and the team that is involved. To be as flexible as possible, Fiber makes no assumptions in terms of structure. Routes and other application-specific logic can live in as many files as you wish, in any directory structure you prefer. View the following examples for inspiration: gofiber/boilerplatethomasvvugt/fiber-boilerplateYoutube - Building a REST API using Gorm and Fiberembedmode/fiberseed "},{"title":"How do I handle custom 404 responses?​","type":1,"pageTitle":"🤔 FAQ","url":"/extra/faq#how-do-i-handle-custom-404-responses","content":"If you're using v2.32.0 or later, all you need to do is to implement a custom error handler. See below, or see a more detailed explanation at Error Handling. If you're using v2.31.0 or earlier, the error handler will not capture 404 errors. Instead, you need to add a middleware function at the very bottom of the stack (below all other functions) to handle a 404 response: Example app.Use(func(c *fiber.Ctx) error { return c.Status(fiber.StatusNotFound).SendString(&quot;Sorry can't find that!&quot;) })  "},{"title":"How do I set up an error handler?​","type":1,"pageTitle":"🤔 FAQ","url":"/extra/faq#how-do-i-set-up-an-error-handler","content":"To override the default error handler, you can override the default when providing a Config when initiating a new Fiber instance. Example app := fiber.New(fiber.Config{ ErrorHandler: func(c *fiber.Ctx, err error) error { return c.Status(fiber.StatusInternalServerError).SendString(err.Error()) }, })  We have a dedicated page explaining how error handling works in Fiber, see Error Handling. "},{"title":"Which template engines does Fiber support?​","type":1,"pageTitle":"🤔 FAQ","url":"/extra/faq#which-template-engines-does-fiber-support","content":"Fiber currently supports 8 template engines in our gofiber/template middleware: AceAmberDjangoHandlebarsHTMLJetMustachePug To learn more about using Templates in Fiber, see Templates. "},{"title":"Does Fiber have a community chat?​","type":1,"pageTitle":"🤔 FAQ","url":"/extra/faq#does-fiber-have-a-community-chat","content":"Yes, we have our own Discord server, where we hang out. We have different rooms for every subject. If you have questions or just want to have a chat, feel free to join us via this &gt; invite link &lt;.  "},{"title":"⚡ Make Fiber Faster","type":0,"sectionRef":"#","url":"/guide/faster-fiber","content":"","keywords":""},{"title":"Custom JSON Encoder/Decoder​","type":1,"pageTitle":"⚡ Make Fiber Faster","url":"/guide/faster-fiber#custom-json-encoderdecoder","content":"Since Fiber v2.32.0, we use encoding/json as default json library due to stability and producibility. However, the standard library is a bit slow compared to 3rd party libraries. If you're not happy with the performance of encoding/json, we recommend you to use these libraries: goccy/go-jsonbytedance/sonicsegmentio/encodingmailru/easyjsonminio/simdjson-gowI2L/jettison Example package main import &quot;github.com/gofiber/fiber/v2&quot; import &quot;github.com/goccy/go-json&quot; func main() { app := fiber.New(fiber.Config{ JSONEncoder: json.Marshal, JSONDecoder: json.Unmarshal, }) # ... }  "},{"title":"References​","type":1,"pageTitle":"⚡ Make Fiber Faster","url":"/guide/faster-fiber#references","content":"Set custom JSON encoder for clientSet custom JSON decoder for clientSet custom JSON encoder for applicationSet custom JSON decoder for application "},{"title":"🐛 Error Handling","type":0,"sectionRef":"#","url":"/guide/error-handling","content":"","keywords":""},{"title":"Catching Errors​","type":1,"pageTitle":"🐛 Error Handling","url":"/guide/error-handling#catching-errors","content":"It’s essential to ensure that Fiber catches all errors that occur while running route handlers and middleware. You must return them to the handler function, where Fiber will catch and process them. Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Pass error to Fiber return c.SendFile(&quot;file-does-not-exist&quot;) })  Fiber does not handle panics by default. To recover from a panic thrown by any handler in the stack, you need to include the Recover middleware below: Example package main import ( &quot;log&quot; &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/fiber/v2/middleware/recover&quot; ) func main() { app := fiber.New() app.Use(recover.New()) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { panic(&quot;This panic is caught by fiber&quot;) }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  You could use Fiber's custom error struct to pass an additional status code using fiber.NewError(). It's optional to pass a message; if this is left empty, it will default to the status code message (404 equals Not Found). Example app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // 503 Service Unavailable return fiber.ErrServiceUnavailable // 503 On vacation! return fiber.NewError(fiber.StatusServiceUnavailable, &quot;On vacation!&quot;) })  "},{"title":"Default Error Handler​","type":1,"pageTitle":"🐛 Error Handling","url":"/guide/error-handling#default-error-handler","content":"Fiber provides an error handler by default. For a standard error, the response is sent as 500 Internal Server Error. If the error is of type fiber.Error, the response is sent with the provided status code and message. Example // Default error handler var DefaultErrorHandler = func(c *fiber.Ctx, err error) error { // Status code defaults to 500 code := fiber.StatusInternalServerError // Retrieve the custom status code if it's a *fiber.Error var e *fiber.Error if errors.As(err, &amp;e) { code = e.Code } // Set Content-Type: text/plain; charset=utf-8 c.Set(fiber.HeaderContentType, fiber.MIMETextPlainCharsetUTF8) // Return status code with error message return c.Status(code).SendString(err.Error()) }  "},{"title":"Custom Error Handler​","type":1,"pageTitle":"🐛 Error Handling","url":"/guide/error-handling#custom-error-handler","content":"A custom error handler can be set using a Config when initializing a Fiber instance. In most cases, the default error handler should be sufficient. However, a custom error handler can come in handy if you want to capture different types of errors and take action accordingly e.g., send a notification email or log an error to the centralized system. You can also send customized responses to the client e.g., error page or just a JSON response. The following example shows how to display error pages for different types of errors. Example // Create a new fiber instance with custom config app := fiber.New(fiber.Config{ // Override default error handler ErrorHandler: func(ctx *fiber.Ctx, err error) error { // Status code defaults to 500 code := fiber.StatusInternalServerError // Retrieve the custom status code if it's a *fiber.Error var e *fiber.Error if errors.As(err, &amp;e) { code = e.Code } // Send custom error page err = ctx.Status(code).SendFile(fmt.Sprintf(&quot;./%d.html&quot;, code)) if err != nil { // In case the SendFile fails return ctx.Status(fiber.StatusInternalServerError).SendString(&quot;Internal Server Error&quot;) } // Return from handler return nil }, }) // ...  Special thanks to the Echo &amp; Express framework for inspiration regarding error handling. "},{"title":"🎭 Grouping","type":0,"sectionRef":"#","url":"/guide/grouping","content":"","keywords":""},{"title":"Paths​","type":1,"pageTitle":"🎭 Grouping","url":"/guide/grouping#paths","content":"Like Routing, groups can also have paths that belong to a cluster. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, middleware) // /api v1 := api.Group(&quot;/v1&quot;, middleware) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, middleware) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user log.Fatal(app.Listen(&quot;:3000&quot;)) }  A Group of paths can have an optional handler. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;) // /api v1 := api.Group(&quot;/v1&quot;) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user log.Fatal(app.Listen(&quot;:3000&quot;)) }  caution Running /api, /v1 or /v2 will result in 404 error, make sure you have the errors set. "},{"title":"Group Handlers​","type":1,"pageTitle":"🎭 Grouping","url":"/guide/grouping#group-handlers","content":"Group handlers can also be used as a routing path but they must have Next added to them so that the flow can continue. func main() { app := fiber.New() handler := func(c *fiber.Ctx) error { return c.SendStatus(fiber.StatusOK) } api := app.Group(&quot;/api&quot;) // /api v1 := api.Group(&quot;/v1&quot;, func(c *fiber.Ctx) error { // middleware for /api/v1 c.Set(&quot;Version&quot;, &quot;v1&quot;) return c.Next() }) v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"🪝 Hooks","type":0,"sectionRef":"#","url":"/guide/hooks","content":"","keywords":""},{"title":"Constants​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#constants","content":"// Handlers define a function to create hooks for Fiber. type OnRouteHandler = func(Route) error type OnNameHandler = OnRouteHandler type OnGroupHandler = func(Group) error type OnGroupNameHandler = OnGroupHandler type OnListenHandler = func() error type OnForkHandler = func(int) error type OnShutdownHandler = OnListenHandler  "},{"title":"OnRoute​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#onroute","content":"OnRoute is a hook to execute user functions on each route registeration. Also you can get route properties by route parameter. Signature func (app *App) OnRoute(handler ...OnRouteHandler)  "},{"title":"OnName​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#onname","content":"OnName is a hook to execute user functions on each route naming. Also you can get route properties by route parameter. caution OnName only works with naming routes, not groups. Signature func (app *App) OnName(handler ...OnNameHandler)  OnName Example package main import ( &quot;fmt&quot; &quot;github.com/gofiber/fiber/v2&quot; ) func main() { app := fiber.New() app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Route().Name) }).Name(&quot;index&quot;) app.Hooks().OnName(func(r fiber.Route) error { fmt.Print(&quot;Name: &quot; + r.Name + &quot;, &quot;) return nil }) app.Hooks().OnName(func(r fiber.Route) error { fmt.Print(&quot;Method: &quot; + r.Method + &quot;\\n&quot;) return nil }) app.Get(&quot;/add/user&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Route().Name) }).Name(&quot;addUser&quot;) app.Delete(&quot;/destroy/user&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Route().Name) }).Name(&quot;destroyUser&quot;) app.Listen(&quot;:5000&quot;) } // Results: // Name: addUser, Method: GET // Name: destroyUser, Method: DELETE  "},{"title":"OnGroup​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#ongroup","content":"OnGroup is a hook to execute user functions on each group registeration. Also you can get group properties by group parameter. Signature func (app *App) OnGroup(handler ...OnGroupHandler)  "},{"title":"OnGroupName​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#ongroupname","content":"OnGroupName is a hook to execute user functions on each group naming. Also you can get group properties by group parameter. caution OnGroupName only works with naming groups, not routes. Signature func (app *App) OnGroupName(handler ...OnGroupNameHandler)  "},{"title":"OnListen​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#onlisten","content":"OnListen is a hook to execute user functions on Listen, ListenTLS, Listener. Signature func (app *App) OnListen(handler ...OnListenHandler)  "},{"title":"OnFork​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#onfork","content":"OnFork is a hook to execute user functions on Fork. Signature func (app *App) OnFork(handler ...OnForkHandler)  "},{"title":"OnShutdown​","type":1,"pageTitle":"🪝 Hooks","url":"/guide/hooks#onshutdown","content":"OnShutdown is a hook to execute user functions after Shutdown. Signature func (app *App) OnShutdown(handler ...OnShutdownHandler)  "},{"title":"📝 Templates","type":0,"sectionRef":"#","url":"/guide/templates","content":"","keywords":""},{"title":"Template interfaces​","type":1,"pageTitle":"📝 Templates","url":"/guide/templates#template-interfaces","content":"Fiber provides a Views interface to provide your own template engine: Views type Views interface { Load() error Render(io.Writer, string, interface{}, ...string) error }  Views interface contains a Load and Render method, Load is executed by Fiber on app initialization to load/parse the templates. // Pass engine to Fiber's Views Engine app := fiber.New(fiber.Config{ Views: engine, // Views Layout is the global layout for all template render until override on Render function. ViewsLayout: &quot;layouts/main&quot; })  The Render method is linked to the ctx.Render() function that accepts a template name and binding data. It will use global layout if layout is not being defined in Render function. If the Fiber config option PassLocalsToViews is enabled, then all locals set using ctx.Locals(key, value) will be passed to the template. app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.Render(&quot;index&quot;, fiber.Map{ &quot;hello&quot;: &quot;world&quot;, }); })  "},{"title":"Engines​","type":1,"pageTitle":"📝 Templates","url":"/guide/templates#engines","content":"Fiber team maintains templates package that provides wrappers for multiple template engines: htmlaceamberdjangohandlebarsjetmustachepug Exampleviews/index.html package main import ( &quot;log&quot; &quot;github.com/gofiber/fiber/v2&quot; &quot;github.com/gofiber/template/html&quot; ) func main() { // Initialize standard Go html template engine engine := html.New(&quot;./views&quot;, &quot;.html&quot;) app := fiber.New(fiber.Config{ Views: engine, }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { // Render index template return c.Render(&quot;index&quot;, fiber.Map{ &quot;Title&quot;: &quot;Hello, World!&quot;, }) }) log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"🔌 Routing","type":0,"sectionRef":"#","url":"/guide/routing","content":"","keywords":""},{"title":"Paths​","type":1,"pageTitle":"🔌 Routing","url":"/guide/routing#paths","content":"Route paths, combined with a request method, define the endpoints at which requests can be made. Route paths can be strings or string patterns. Examples of route paths based on strings // This route path will match requests to the root route, &quot;/&quot;: app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;root&quot;) }) // This route path will match requests to &quot;/about&quot;: app.Get(&quot;/about&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;about&quot;) }) // This route path will match requests to &quot;/random.txt&quot;: app.Get(&quot;/random.txt&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;random.txt&quot;) })  As with the expressJs framework, the order of the route declaration plays a role. When a request is received, the routes are checked in the order in which they are declared. info So please be careful to write routes with variable parameters after the routes that contain fixed parts, so that these variable parts do not match instead and unexpected behavior occurs. "},{"title":"Parameters​","type":1,"pageTitle":"🔌 Routing","url":"/guide/routing#parameters","content":"Route parameters are dynamic elements in the route, which are named or not named segments. This segments that are used to capture the values specified at their position in the URL. The obtained values can be retrieved using the Params function, with the name of the route parameter specified in the path as their respective keys or for unnamed parameters the character(*, +) and the counter of this. The characters :, +, and * are characters that introduce a parameter. Greedy parameters are indicated by wildcard(*) or plus(+) signs. The routing also offers the possibility to use optional parameters, for the named parameters these are marked with a final &quot;?&quot;, unlike the plus sign which is not optional, you can use the wildcard character for a parameter range which is optional and greedy. Example of define routes with route parameters // Parameters app.Get(&quot;/user/:name/books/:title&quot;, func(c *fiber.Ctx) error { fmt.Fprintf(c, &quot;%s\\n&quot;, c.Params(&quot;name&quot;)) fmt.Fprintf(c, &quot;%s\\n&quot;, c.Params(&quot;title&quot;)) return nil }) // Plus - greedy - not optional app.Get(&quot;/user/+&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;+&quot;)) }) // Optional parameter app.Get(&quot;/user/:name?&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;name&quot;)) }) // Wildcard - greedy - optional app.Get(&quot;/user/*&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;*&quot;)) }) // This route path will match requests to &quot;/v1/some/resource/name:customVerb&quot;, since the parameter character is escaped app.Get(&quot;/v1/some/resource/name\\\\:customVerb&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Hello, Community&quot;) })  info Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes. info All special parameter characters can also be escaped with &quot;\\\\&quot; and lose their value, so you can use them in the route if you want, like in the custom methods of the google api design guide. // http://localhost:3000/plantae/prunus.persica app.Get(&quot;/plantae/:genus.:species&quot;, func(c *fiber.Ctx) error { fmt.Fprintf(c, &quot;%s.%s\\n&quot;, c.Params(&quot;genus&quot;), c.Params(&quot;species&quot;)) return nil // prunus.persica })  // http://localhost:3000/flights/LAX-SFO app.Get(&quot;/flights/:from-:to&quot;, func(c *fiber.Ctx) error { fmt.Fprintf(c, &quot;%s-%s\\n&quot;, c.Params(&quot;from&quot;), c.Params(&quot;to&quot;)) return nil // LAX-SFO })  Our intelligent router recognizes that the introductory parameter characters should be part of the request route in this case and can process them as such. // http://localhost:3000/shop/product/color:blue/size:xs app.Get(&quot;/shop/product/color::color/size::size&quot;, func(c *fiber.Ctx) error { fmt.Fprintf(c, &quot;%s:%s\\n&quot;, c.Params(&quot;color&quot;), c.Params(&quot;size&quot;)) return nil // blue:xs })  In addition, several parameters in a row and several unnamed parameter characters in the route, such as the wildcard or plus character, are possible, which greatly expands the possibilities of the router for the user. // GET /@v1 // Params: &quot;sign&quot; -&gt; &quot;@&quot;, &quot;param&quot; -&gt; &quot;v1&quot; app.Get(&quot;/:sign:param&quot;, handler) // GET /api-v1 // Params: &quot;name&quot; -&gt; &quot;v1&quot; app.Get(&quot;/api-:name&quot;, handler) // GET /customer/v1/cart/proxy // Params: &quot;*1&quot; -&gt; &quot;customer/&quot;, &quot;*2&quot; -&gt; &quot;/cart&quot; app.Get(&quot;/*v1*/proxy&quot;, handler) // GET /v1/brand/4/shop/blue/xs // Params: &quot;*1&quot; -&gt; &quot;brand/4&quot;, &quot;*2&quot; -&gt; &quot;blue/xs&quot; app.Get(&quot;/v1/*/shop/*&quot;, handler)  We have adapted the routing strongly to the express routing, but currently without the possibility of the regular expressions, because they are quite slow. The possibilities can be tested with version 0.1.7 (express 4) in the online Express route tester. "},{"title":"Constraints​","type":1,"pageTitle":"🔌 Routing","url":"/guide/routing#constraints","content":"Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values by parameters. The feature was intorduced in v2.37.0 and inspired by .NET Core. caution Constraints aren't validation for parameters. If constraint aren't valid for parameter value, Fiber returns 404 handler. Constraint\tExample\tExample matchesint\t:id&lt;int&gt;\t123456789, -123456789 bool\t:active&lt;bool&gt;\ttrue,false guid\t:id&lt;guid&gt;\tCD2C1638-1638-72D5-1638-DEADBEEF1638 float\t:weight&lt;float&gt;\t1.234, -1,001.01e8 minLen(value)\t:username&lt;minLen(4)&gt;\tTest (must be at least 4 characters) maxLen(value)\t:filename&lt;maxLen(8)&gt;\tMyFile (must be no more than 8 characters len(length)\t:filename&lt;len(12)&gt;\tsomefile.txt (exactly 12 characters) min(value)\t:age&lt;min(18)&gt;\t19 (Integer value must be at least 18) max(value)\t:age&lt;max(120)&gt;\t91 (Integer value must be no more than 120) range(min,max)\t:age&lt;range(18,120)&gt;\t91 (Integer value must be at least 18 but no more than 120) alpha\t:name&lt;alpha&gt;\tRick (String must consist of one or more alphabetical characters, a-z and case-insensitive) datetime\t:dob&lt;datetime(2006\\\\-01\\\\-02)&gt;\t2005-11-01 regex(expression)\t:date&lt;regex(\\d{4}-\\d{2}-\\d{2})}&gt;\t2022-08-27 (Must match regular expression) Examples Single ConstraintMultiple ConstraintsRegex Constraint app.Get(&quot;/:test&lt;min(5)&gt;&quot;, func(c *fiber.Ctx) error { return c.SendString(c.Params(&quot;test&quot;)) }) // curl -X GET http://localhost:3000/12 // 12 // curl -X GET http://localhost:3000/1 // Cannot GET /1  caution You should use \\\\ before routing-specific characters when to use datetime constraint (*, +, ?, :, /, &lt;, &gt;, ;, (, )), to avoid wrong parsing. "},{"title":"Middleware​","type":1,"pageTitle":"🔌 Routing","url":"/guide/routing#middleware","content":"Functions that are designed to make changes to the request or response are called middleware functions. The Next is a Fiber router function, when called, executes the next function that matches the current route. Example of a middleware function app.Use(func(c *fiber.Ctx) error { // Set a custom header on all responses: c.Set(&quot;X-Custom-Header&quot;, &quot;Hello, World&quot;) // Go to next middleware: return c.Next() }) app.Get(&quot;/&quot;, func(c *fiber.Ctx) error { return c.SendString(&quot;Hello, World!&quot;) })  Use method path is a mount, or prefix path, and limits middleware to only apply to any paths requested that begin with it. "},{"title":"Grouping​","type":1,"pageTitle":"🔌 Routing","url":"/guide/routing#grouping","content":"If you have many endpoints, you can organize your routes using Group. func main() { app := fiber.New() api := app.Group(&quot;/api&quot;, middleware) // /api v1 := api.Group(&quot;/v1&quot;, middleware) // /api/v1 v1.Get(&quot;/list&quot;, handler) // /api/v1/list v1.Get(&quot;/user&quot;, handler) // /api/v1/user v2 := api.Group(&quot;/v2&quot;, middleware) // /api/v2 v2.Get(&quot;/list&quot;, handler) // /api/v2/list v2.Get(&quot;/user&quot;, handler) // /api/v2/user log.Fatal(app.Listen(&quot;:3000&quot;)) }  "},{"title":"🔎 Validation","type":0,"sectionRef":"#","url":"/guide/validation","content":"","keywords":""},{"title":"Validator package​","type":1,"pageTitle":"🔎 Validation","url":"/guide/validation#validator-package","content":"Fiber can make great use of the validator package to ensure correct validation of data to store. Official validator Github page (Installation, use, examples..). You can find the detailed descriptions of the validations used in the fields contained on the structs below: Detailed docs Validation Example type Job struct{ Type string `validate:&quot;required,min=3,max=32&quot;` Salary int `validate:&quot;required,number&quot;` } type User struct{ Name string `validate:&quot;required,min=3,max=32&quot;` // use `*bool` here otherwise the validation will fail for `false` values // Ref: https://github.com/go-playground/validator/issues/319#issuecomment-339222389 IsActive *bool `validate:&quot;required&quot;` Email string `validate:&quot;required,email,min=6,max=32&quot;` Job Job `validate:&quot;dive&quot;` } type ErrorResponse struct { FailedField string Tag string Value string } var validate = validator.New() func ValidateStruct(user User) []*ErrorResponse { var errors []*ErrorResponse err := validate.Struct(user) if err != nil { for _, err := range err.(validator.ValidationErrors) { var element ErrorResponse element.FailedField = err.StructNamespace() element.Tag = err.Tag() element.Value = err.Param() errors = append(errors, &amp;element) } } return errors } func AddUser(c *fiber.Ctx) error { //Connect to database user := new(User) if err := c.BodyParser(user); err != nil { return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{ &quot;message&quot;: err.Error(), }) } errors := ValidateStruct(*user) if errors != nil { return c.Status(fiber.StatusBadRequest).JSON(errors) } //Do something else here //Return user return c.JSON(user) } // Running a test with the following curl commands // curl -X POST -H &quot;Content-Type: application/json&quot; --data &quot;{\\&quot;name\\&quot;:\\&quot;john\\&quot;,\\&quot;isactive\\&quot;:\\&quot;True\\&quot;}&quot; http://localhost:8080/register/user // Results in // [{&quot;FailedField&quot;:&quot;User.Email&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;},{&quot;FailedField&quot;:&quot;User.Job.Salary&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;},{&quot;FailedField&quot;:&quot;User.Job.Type&quot;,&quot;Tag&quot;:&quot;required&quot;,&quot;Value&quot;:&quot;&quot;}]⏎  "}]